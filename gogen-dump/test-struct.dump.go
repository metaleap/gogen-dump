package main

// Code generated by github.com/go-leap/gen/gogen-dump â€” DO NOT EDIT.

import (
	"bytes"
	"io"
	"unsafe"
	
)


func (me *testStruct) writeTo(buf *bytes.Buffer) (err error) {
	var data bytes.Buffer
	
	if err = me.embName.writeTo(&data); err != nil { return } ; l_embName := uint64(data.Len()) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_embName))[:]) ; data.WriteTo(buf)
	
	if me.Deleted { buf.WriteByte(1) } else { buf.WriteByte(0) }
	
	if me.Balance == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		for i_Balance := 0; i_Balance < 3; i_Balance++ {
		if (*me.Balance)[i_Balance] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; if *(*me.Balance)[i_Balance] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		buf.Write(((*[2]byte)(unsafe.Pointer(*(*me.Balance)[i_Balance])))[:])
	}}
	}
	}
	
	int64_AccountAge := int64(me.AccountAge) ; buf.Write(((*[8]byte)(unsafe.Pointer(&int64_AccountAge)))[:])
	
	l_Any := uint64(len(me.Any)) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_Any))[:]) ; for i_Any := 0; i_Any < int(l_Any); i_Any++ {
		switch t_i_Any := me.Any[i_Any].(type) {
		case *embName:
			buf.WriteByte(1) ; if t_i_Any == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		if err = t_i_Any.writeTo(&data); err != nil { return } ; l_i_Any := uint64(data.Len()) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_i_Any))[:]) ; data.WriteTo(buf)
	}
		case []embName:
			buf.WriteByte(2) ; l_i_Any := uint64(len(t_i_Any)) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_i_Any))[:]) ; for ii_i_Any := 0; ii_i_Any < int(l_i_Any); ii_i_Any++ {
		if err = t_i_Any[ii_i_Any].writeTo(&data); err != nil { return } ; l_ii_i_Any := uint64(data.Len()) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_ii_i_Any))[:]) ; data.WriteTo(buf)
	}
		case []*embName:
			buf.WriteByte(3) ; l_i_Any := uint64(len(t_i_Any)) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_i_Any))[:]) ; for ii_i_Any := 0; ii_i_Any < int(l_i_Any); ii_i_Any++ {
		if t_i_Any[ii_i_Any] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		if err = t_i_Any[ii_i_Any].writeTo(&data); err != nil { return } ; l_ii_i_Any := uint64(data.Len()) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_ii_i_Any))[:]) ; data.WriteTo(buf)
	}
	}
		case []*float32:
			buf.WriteByte(4) ; l_i_Any := uint64(len(t_i_Any)) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_i_Any))[:]) ; for ii_i_Any := 0; ii_i_Any < int(l_i_Any); ii_i_Any++ {
		if t_i_Any[ii_i_Any] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		buf.Write(((*[4]byte)(unsafe.Pointer(t_i_Any[ii_i_Any])))[:])
	}
	}
		default:
			buf.WriteByte(0)
	}
	}
	
	l_Foo := uint64(len(me.Foo)) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_Foo))[:]) ; for mk_Foo, mv_Foo := range me.Foo {
		l_mk_Foo := uint64(len(mk_Foo)) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_mk_Foo))[:]) ; buf.WriteString(mk_Foo)
		buf.Write(((*[16]byte)(unsafe.Pointer(&(mv_Foo))))[:])
	}
	
	if me.Age == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; if *me.Age == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; if **me.Age == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		uint64_Age := uint64((***me.Age)) ; buf.Write(((*[8]byte)(unsafe.Pointer(&uint64_Age)))[:])
	}}}
	
	buf.Write(((*[4]byte)(unsafe.Pointer(&(me.R))))[:])
	
	return
}

func (me *testStruct) WriteTo(w io.Writer) (int64, error) {
	if data, err := me.MarshalBinary(); err == nil {
		var n int
		n, err = w.Write(data)
		return int64(n), err
	} else {
		return 0, err
	}
}

func (me *testStruct) MarshalBinary() (data []byte, err error) {
	var buf bytes.Buffer
	if err = me.writeTo(&buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *testStruct) UnmarshalBinary(data []byte) (err error) {
	var pos int
	
	l_embName := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; if err = me.embName.UnmarshalBinary(data[pos : pos+l_embName]); err != nil { return } ; pos += l_embName
	
	me.Deleted= (data[pos] == 1) ; pos++
	
	if data[pos] == 0 { pos++ ; me.Balance = nil } else { pos++ ; 
		v_Balance:= [3]**int16{} ; for i_Balance := 0; i_Balance < 3; i_Balance++ {
		if data[pos] == 0 { pos++ } else { pos++ ; if data[pos] == 0 { pos++ } else { pos++ ; 
		v_i_Balance:= *((*int16)(unsafe.Pointer(&data[pos]))) ; pos += 2 ; p0_i_Balance := &v_i_Balance ; v_Balance[i_Balance] = &p0_i_Balance
	}}
	} ; me.Balance = &v_Balance
	}
	
	me.AccountAge= int(*((*int64)(unsafe.Pointer(&data[pos])))) ; pos += 8
	
	l_Any := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; me.Any= make([]interface{}, l_Any) ; for i_Any := 0; i_Any < int(l_Any); i_Any++ {
		t_i_Any := data[pos] ; pos++ ; switch t_i_Any {
		case 1:
			if data[pos] == 0 { pos++ ; me.Any[i_Any] = nil } else { pos++ ; 
		v_i_Any:= embName{} ; l_i_Any := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; if err = v_i_Any.UnmarshalBinary(data[pos : pos+l_i_Any]); err != nil { return } ; pos += l_i_Any ; me.Any[i_Any] = &v_i_Any
	}
		case 2:
			l_i_Any := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; me.Any[i_Any]= make([]embName, l_i_Any) ; for ii_i_Any := 0; ii_i_Any < int(l_i_Any); ii_i_Any++ {
		l_ii_i_Any := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; if err = me.Any[i_Any].([]embName)[ii_i_Any].UnmarshalBinary(data[pos : pos+l_ii_i_Any]); err != nil { return } ; pos += l_ii_i_Any
	}
		case 3:
			l_i_Any := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; me.Any[i_Any]= make([]*embName, l_i_Any) ; for ii_i_Any := 0; ii_i_Any < int(l_i_Any); ii_i_Any++ {
		if data[pos] == 0 { pos++ ; me.Any[i_Any].([]*embName)[ii_i_Any] = nil } else { pos++ ; 
		v_ii_i_Any:= embName{} ; l_ii_i_Any := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; if err = v_ii_i_Any.UnmarshalBinary(data[pos : pos+l_ii_i_Any]); err != nil { return } ; pos += l_ii_i_Any ; me.Any[i_Any].([]*embName)[ii_i_Any] = &v_ii_i_Any
	}
	}
		case 4:
			l_i_Any := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; me.Any[i_Any]= make([]*float32, l_i_Any) ; for ii_i_Any := 0; ii_i_Any < int(l_i_Any); ii_i_Any++ {
		if data[pos] == 0 { pos++ ; me.Any[i_Any].([]*float32)[ii_i_Any] = nil } else { pos++ ; 
		v_ii_i_Any:= *((*float32)(unsafe.Pointer(&data[pos]))) ; pos += 4 ; me.Any[i_Any].([]*float32)[ii_i_Any] = &v_ii_i_Any
	}
	}
		default:
			me.Any[i_Any] = nil
	}
	}
	
	l_Foo := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; me.Foo= make(map[string]complex128, l_Foo) ; for i_Foo := 0; i_Foo < int(l_Foo); i_Foo++ {
	}
	
	if data[pos] == 0 { pos++ ; me.Age = nil } else { pos++ ; if data[pos] == 0 { pos++ ; me.Age = nil } else { pos++ ; if data[pos] == 0 { pos++ ; me.Age = nil } else { pos++ ; 
		v_Age:= uint(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; p0_Age := &v_Age ; p1_Age := &p0_Age ; me.Age = &p1_Age
	}}}
	
	me.R= *((*rune)(unsafe.Pointer(&data[pos]))) ; pos += 4
	
	return
}

func (me *embName) writeTo(buf *bytes.Buffer) (err error) {
	
	
	l_FirstName := uint64(len(me.FirstName)) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_FirstName))[:]) ; buf.WriteString(me.FirstName)
	
	if me.MiddleNames == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		l_MiddleNames := uint64(len((*me.MiddleNames))) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_MiddleNames))[:]) ; for i_MiddleNames := 0; i_MiddleNames < int(l_MiddleNames); i_MiddleNames++ {
		if (*me.MiddleNames)[i_MiddleNames] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; if *(*me.MiddleNames)[i_MiddleNames] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; if **(*me.MiddleNames)[i_MiddleNames] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		for ii_i_MiddleNames := 0; ii_i_MiddleNames < 4; ii_i_MiddleNames++ {
		if (***(*me.MiddleNames)[i_MiddleNames])[ii_i_MiddleNames] == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		l_ii_i_MiddleNames := uint64(len((*(***(*me.MiddleNames)[i_MiddleNames])[ii_i_MiddleNames]))) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_ii_i_MiddleNames))[:]) ; buf.WriteString((*(***(*me.MiddleNames)[i_MiddleNames])[ii_i_MiddleNames]))
	}
	}
	}}}
	}
	}
	
	if me.LastName == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; if *me.LastName == nil { buf.WriteByte(0) } else { buf.WriteByte(1) ; 
		l_LastName := uint64(len((**me.LastName))) ; buf.Write((*[8]byte)(unsafe.Pointer(&l_LastName))[:]) ; buf.WriteString((**me.LastName))
	}}
	
	return
}

func (me *embName) WriteTo(w io.Writer) (int64, error) {
	if data, err := me.MarshalBinary(); err == nil {
		var n int
		n, err = w.Write(data)
		return int64(n), err
	} else {
		return 0, err
	}
}

func (me *embName) MarshalBinary() (data []byte, err error) {
	var buf bytes.Buffer
	if err = me.writeTo(&buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *embName) UnmarshalBinary(data []byte) (err error) {
	var pos int
	
	l_FirstName := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; me.FirstName= string(data[pos : pos+l_FirstName]) ; pos += l_FirstName
	
	if data[pos] == 0 { pos++ ; me.MiddleNames = nil } else { pos++ ; 
		l_MiddleNames := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; v_MiddleNames:= make([]***[4]*string, l_MiddleNames) ; for i_MiddleNames := 0; i_MiddleNames < int(l_MiddleNames); i_MiddleNames++ {
		if data[pos] == 0 { pos++ } else { pos++ ; if data[pos] == 0 { pos++ } else { pos++ ; if data[pos] == 0 { pos++ } else { pos++ ; 
		v_i_MiddleNames:= [4]*string{} ; for ii_i_MiddleNames := 0; ii_i_MiddleNames < 4; ii_i_MiddleNames++ {
		if data[pos] == 0 { pos++ } else { pos++ ; 
		l_ii_i_MiddleNames := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; v_ii_i_MiddleNames:= string(data[pos : pos+l_ii_i_MiddleNames]) ; pos += l_ii_i_MiddleNames ; v_i_MiddleNames[ii_i_MiddleNames] = &v_ii_i_MiddleNames
	}
	} ; p0_i_MiddleNames := &v_i_MiddleNames ; p1_i_MiddleNames := &p0_i_MiddleNames ; v_MiddleNames[i_MiddleNames] = &p1_i_MiddleNames
	}}}
	} ; me.MiddleNames = &v_MiddleNames
	}
	
	if data[pos] == 0 { pos++ ; me.LastName = nil } else { pos++ ; if data[pos] == 0 { pos++ ; me.LastName = nil } else { pos++ ; 
		l_LastName := int(*((*uint64)(unsafe.Pointer(&data[pos])))) ; pos += 8 ; v_LastName:= string(data[pos : pos+l_LastName]) ; pos += l_LastName ; p0_LastName := &v_LastName ; me.LastName = &p0_LastName
	}}
	
	return
}

