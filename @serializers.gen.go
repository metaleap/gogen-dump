package main

// Code generated by github.com/metaleap/gogen-dump - DO NOT EDIT.

// This file consists solely of generated (de)serialization methods for the following 13 struct type(s).
// - city (signature: 1371017976213158072)
// - company (signature: 1099423678947472881)
// - family (signature: 4523365645226592426)
// - fixedSize (signature: 3387551728070519514)
// - hobby (signature: 5837267412986298571)
// - person (signature: 11925296559860657288)
// - pet (signature: 13186359848934745181)
// - petCat (signature: 13481110904349996911)
// - petDog (signature: 3596748310628763049)
// - petHamster (signature: 13333275131017623849)
// - petPiranha (signature: 11146996824496730984)
// - school (signature: 11190834307079325616)
// - simWorld (signature: 8840850003979738572)

import (
	"bytes"
	"errors"
	"io"
	"unsafe"

	time "time"
)

/* city:
   5 field(s)

   The serialization view:
   - Name - string
   - ClosestTo - *****city
   - Companies - []company
   - Families - **[]family
   - Schools - **[]**school
*/

func (me *city) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// Name
	{
		lName := (len(me.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(me.Name)
	}
	// ClosestTo
	if me.ClosestTo == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.ClosestTo
		if pv000 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv100 := *pv000
			if pv100 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv200 := *pv100
				if pv200 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					pv300 := *pv200
					if pv300 == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						if err = pv300.marshalTo(buf, addrs); err != nil {
							return
						}
					}
				}
			}
		}
	}
	// Companies
	{
		lCompanies := (len(me.Companies))
		buf.Write((*[8]byte)(unsafe.Pointer(&lCompanies))[:])
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = me.Companies[i0].marshalTo(buf, addrs); err != nil {
				return
			}
		}
	}
	// Families
	if me.Families == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Families
		if pv000 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv100 := *pv000
			{
				lFamilies := (len(pv100))
				buf.Write((*[8]byte)(unsafe.Pointer(&lFamilies))[:])
				for i0 := 0; i0 < (lFamilies); i0++ {
					if err = pv100[i0].marshalTo(buf, addrs); err != nil {
						return
					}
				}
			}
		}
	}
	// Schools
	if me.Schools == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Schools
		if pv000 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv100 := *pv000
			{
				lSchools := (len(pv100))
				buf.Write((*[8]byte)(unsafe.Pointer(&lSchools))[:])
				for i0 := 0; i0 < (lSchools); i0++ {
					if pv100[i0] == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						pv010 := *pv100[i0]
						if pv010 == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = pv010.marshalTo(buf, addrs); err != nil {
								return
							}
						}
					}
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *city) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((((8 + len(me.Name)) + 13) + (8 + (len(me.Companies) * 1074))) + 152) + 4102)))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *city) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// Name
	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Name = string(data[p : p+lName])
		p += lName
	}
	// ClosestTo
	{
		var p000 *****city
		if p++; data[p-1] != 0 {
			var p100 ****city
			if p++; data[p-1] != 0 {
				var p200 ***city
				if p++; data[p-1] != 0 {
					var p300 **city
					if p++; data[p-1] != 0 {
						var p400 *city
						if p++; data[p-1] != 0 {
							v500 := city{}
							if err = v500.unmarshalFrom(&p, data, addrs); err != nil {
								return
							}
							p400 = &v500
						}
						p300 = &p400
					}
					p200 = &p300
				}
				p100 = &p200
			}
			p000 = &p100
		}
		me.ClosestTo = p000
	}
	// Companies
	{
		lCompanies := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Companies = make([]company, lCompanies)
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = me.Companies[i0].unmarshalFrom(&p, data, addrs); err != nil {
				return
			}
		}
	}
	// Families
	{
		var p000 **[]family
		if p++; data[p-1] != 0 {
			var p100 *[]family
			if p++; data[p-1] != 0 {
				lFamilies := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				v200 := make([]family, lFamilies)
				for i0 := 0; i0 < (lFamilies); i0++ {
					v200[i0] = family{}
					if err = v200[i0].unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
				}
				p100 = &v200
			}
			p000 = &p100
		}
		me.Families = p000
	}
	// Schools
	{
		var p000 **[]**school
		if p++; data[p-1] != 0 {
			var p100 *[]**school
			if p++; data[p-1] != 0 {
				lSchools := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				v200 := make([]**school, lSchools)
				for i0 := 0; i0 < (lSchools); i0++ {
					{
						var p010 **school
						if p++; data[p-1] != 0 {
							var p110 *school
							if p++; data[p-1] != 0 {
								v210 := school{}
								if err = v210.unmarshalFrom(&p, data, addrs); err != nil {
									return
								}
								p110 = &v210
							}
							p010 = &p110
						}
						v200[i0] = p010
					}
				}
				p100 = &v200
			}
			p000 = &p100
		}
		me.Schools = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *city) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *city) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 1371017976213158072 {
			err = errors.New("city: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *city) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((((8 + len(me.Name)) + 13) + (8 + (len(me.Companies) * 1074))) + 152) + 4102)))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{1371017976213158072, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* company:
   3 field(s)

   The serialization view:
   - Suppliers - []*company
   - Clients - []*company
   - Staff - []*person
*/

func (me *company) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// Suppliers
	{
		lSuppliers := (len(me.Suppliers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lSuppliers))[:])
		for i0 := 0; i0 < (lSuppliers); i0++ {
			if me.Suppliers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = me.Suppliers[i0].marshalTo(buf, addrs); err != nil {
					return
				}
			}
		}
	}
	// Clients
	{
		lClients := (len(me.Clients))
		buf.Write((*[8]byte)(unsafe.Pointer(&lClients))[:])
		for i0 := 0; i0 < (lClients); i0++ {
			if me.Clients[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = me.Clients[i0].marshalTo(buf, addrs); err != nil {
					return
				}
			}
		}
	}
	// Staff
	{
		lStaff := (len(me.Staff))
		buf.Write((*[8]byte)(unsafe.Pointer(&lStaff))[:])
		for i0 := 0; i0 < (lStaff); i0++ {
			if me.Staff[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = me.Staff[i0].marshalTo(buf, addrs); err != nil {
					return
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *company) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((8 + (len(me.Suppliers) * 9)) + (8 + (len(me.Clients) * 9))) + (8 + (len(me.Staff) * 507)))))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *company) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// Suppliers
	{
		lSuppliers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Suppliers = make([]*company, lSuppliers)
		for i0 := 0; i0 < (lSuppliers); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p010 = &v110
				}
				me.Suppliers[i0] = p010
			}
		}
	}
	// Clients
	{
		lClients := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Clients = make([]*company, lClients)
		for i0 := 0; i0 < (lClients); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p010 = &v110
				}
				me.Clients[i0] = p010
			}
		}
	}
	// Staff
	{
		lStaff := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Staff = make([]*person, lStaff)
		for i0 := 0; i0 < (lStaff); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p010 = &v110
				}
				me.Staff[i0] = p010
			}
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *company) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *company) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 1099423678947472881 {
			err = errors.New("company: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *company) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((8 + (len(me.Suppliers) * 9)) + (8 + (len(me.Clients) * 9))) + (8 + (len(me.Staff) * 507)))))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{1099423678947472881, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* family:
   2 field(s)

   The serialization view:
   - LastName - string
   - Pets - map[string]*petAnimal = [ *petCat | *petDog | *petHamster | *petPiranha ]
*/

func (me *family) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// LastName
	{
		lLastName := (len(me.LastName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastName))[:])
		buf.WriteString(me.LastName)
	}
	// Pets
	{
		lPets := (len(me.Pets))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPets))[:])
		for k0, m0 := range me.Pets {
			lk0 := (len(k0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
			buf.WriteString(k0)
			if m0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				{
					switch t := (*m0).(type) {
					case *petCat:
						buf.WriteByte(1)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf, addrs); err != nil {
								return
							}
						}
					case *petDog:
						buf.WriteByte(2)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf, addrs); err != nil {
								return
							}
						}
					case *petHamster:
						buf.WriteByte(3)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf, addrs); err != nil {
								return
							}
						}
					case *petPiranha:
						buf.WriteByte(4)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf, addrs); err != nil {
								return
							}
						}
					case nil:
						buf.WriteByte(0)
					default:
						panic("family.marshalTo: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
						// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
					}
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *family) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + len(me.LastName)) + (8 + ((len(me.Pets) * 15) + (len(me.Pets) * 9))))))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *family) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// LastName
	{
		lLastName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.LastName = string(data[p : p+lLastName])
		p += lLastName
	}
	// Pets
	{
		lPets := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Pets = make(map[string]*petAnimal, lPets)
		for i0 := 0; i0 < (lPets); i0++ {
			var bk0 string
			var bm0 *petAnimal
			lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bk0 = string(data[p : p+lk0])
			p += lk0
			{
				var p014 *petAnimal
				if p++; data[p-1] != 0 {
					var v114 petAnimal
					{
						t := data[p]
						p++
						switch t {
						case 1:
							var u *petCat
							{
								var p010 *petCat
								if p++; data[p-1] != 0 {
									v110 := petCat{}
									if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 2:
							var u *petDog
							{
								var p010 *petDog
								if p++; data[p-1] != 0 {
									v110 := petDog{}
									if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 3:
							var u *petHamster
							{
								var p010 *petHamster
								if p++; data[p-1] != 0 {
									v110 := petHamster{}
									if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 4:
							var u *petPiranha
							{
								var p010 *petPiranha
								if p++; data[p-1] != 0 {
									v110 := petPiranha{}
									if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						default:
							v114 = nil
						}
					}
					p014 = &v114
				}
				bm0 = p014
			}
			me.Pets[bk0] = bm0
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *family) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *family) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 4523365645226592426 {
			err = errors.New("family: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *family) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + len(me.LastName)) + (8 + ((len(me.Pets) * 15) + (len(me.Pets) * 9))))))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{4523365645226592426, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* fixedSize:
   13 field(s), always 3384b

   The serialization view:
   - eight1 - float64, 8b, begins fixed-size span of ~3380b (+padding/alignment..) over the next 12 field(s)
   - eight2 - [1]uint64, 8b
   - eight3 - [2][3]int64, 48b
   - eight4 - [4][5]complex64, 160b
   - four1 - [6][7]float32, 168b
   - four2 - [8][9]int32, 288b
   - four3 - [8][7]uint32, 224b
   - four4 - [6][5]rune, 120b
   - one1 - [4][3]uint8, 12b
   - one2 - [2][1]int8, 2b
   - one3 - [2][3]byte, 6b
   - sixt1 - [4][5]complex128, 320b
   - sixt2 - [6][7]complex384, 2016b
*/

func (me *fixedSize) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	buf.Write((*[3384]byte)(unsafe.Pointer(me))[:])
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *fixedSize) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *fixedSize) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	*me = *((*fixedSize)(unsafe.Pointer(&data[*pos])))
	*pos += 3384
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *fixedSize) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *fixedSize) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 3387551728070519514 {
			err = errors.New("fixedSize: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *fixedSize) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{3387551728070519514, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* hobby:
   8 field(s)

   The serialization view:
   - Name - string
   - PopularityScore - float64, 8b, begins fixed-size span of ~46b (+padding/alignment..) over the next 5 field(s)
   - AvgPerDay.TimeNeededMinMax - [2]time.Duration, 16b
   - AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere - bool, 1b
   - AvgPerDay.CostInCentsMinMax - [2]uint16, 4b
   - GroupSizeMinMax - [2]uint, 16b
   - Outdoorsy - bool, 1b
   - Description - *string
*/

func (me *hobby) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// Name
	{
		lName := (len(me.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(me.Name)
	}
	// PopularityScore, AvgPerDay.TimeNeededMinMax, AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere, AvgPerDay.CostInCentsMinMax, GroupSizeMinMax, Outdoorsy
	buf.Write((*[46]byte)(unsafe.Pointer(&me.PopularityScore))[:])
	// Description
	if me.Description == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Description
		{
			lDescription := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lDescription))[:])
			buf.WriteString(pv000)
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *hobby) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((((8 + len(me.Name)) + 8) + 16) + 1) + 4) + 16) + 1) + 16)))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *hobby) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// Name
	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Name = string(data[p : p+lName])
		p += lName
	}
	// PopularityScore, AvgPerDay.TimeNeededMinMax, AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere, AvgPerDay.CostInCentsMinMax, GroupSizeMinMax, Outdoorsy
	*((*[46]byte)(unsafe.Pointer(&me.PopularityScore))) = *((*[46]byte)(unsafe.Pointer(&data[p])))
	p += 46
	// Description
	{
		var p000 *string
		if p++; data[p-1] != 0 {
			lDescription := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := string(data[p : p+lDescription])
			p += lDescription
			p000 = &v100
		}
		me.Description = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *hobby) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *hobby) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 5837267412986298571 {
			err = errors.New("hobby: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *hobby) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((((8 + len(me.Name)) + 8) + 16) + 1) + 4) + 16) + 1) + 16)))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{5837267412986298571, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* person:
   6 field(s)

   The serialization view:
   - FirstName - string
   - Family - *family
   - DateOfBirth - time.Time
   - Parents - [2]*person
   - FavPet - interface{} = [ *petCat | *petDog | *petHamster | *petPiranha ]
   - Top5Hobbies - [5]hobby
*/

func (me *person) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// FirstName
	{
		lFirstName := (len(me.FirstName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lFirstName))[:])
		buf.WriteString(me.FirstName)
	}
	// Family
	if me.Family == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		if err = me.Family.marshalTo(buf, addrs); err != nil {
			return
		}
	}
	// DateOfBirth
	{
		d, e := me.DateOfBirth.MarshalBinary()
		if err = e; err != nil {
			return
		}
		lDateOfBirth := (len(d))
		buf.Write((*[8]byte)(unsafe.Pointer(&lDateOfBirth))[:])
		buf.Write(d)
	}
	// Parents
	for i0 := 0; i0 < 2; i0++ {
		if me.Parents[i0] == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			if err = me.Parents[i0].marshalTo(buf, addrs); err != nil {
				return
			}
		}
	}
	// FavPet
	{
		switch t := me.FavPet.(type) {
		case *petCat:
			buf.WriteByte(1)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf, addrs); err != nil {
					return
				}
			}
		case *petDog:
			buf.WriteByte(2)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf, addrs); err != nil {
					return
				}
			}
		case *petHamster:
			buf.WriteByte(3)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf, addrs); err != nil {
					return
				}
			}
		case *petPiranha:
			buf.WriteByte(4)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf, addrs); err != nil {
					return
				}
			}
		case nil:
			buf.WriteByte(0)
		default:
			panic("person.marshalTo, FavPet field: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
			// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
		}
	}
	// Top5Hobbies
	for i0 := 0; i0 < 5; i0++ {
		if err = me.Top5Hobbies[i0].marshalTo(buf, addrs); err != nil {
			return
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *person) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((8 + len(me.FirstName)) + 72) + 8) + 18) + 8) + 385)))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *person) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// FirstName
	{
		lFirstName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.FirstName = string(data[p : p+lFirstName])
		p += lFirstName
	}
	// Family
	{
		var p000 *family
		if p++; data[p-1] != 0 {
			v100 := family{}
			if err = v100.unmarshalFrom(&p, data, addrs); err != nil {
				return
			}
			p000 = &v100
		}
		me.Family = p000
	}
	// DateOfBirth
	{
		lDateOfBirth := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		if lDateOfBirth > 0 {
			if err = me.DateOfBirth.UnmarshalBinary(data[p : p+lDateOfBirth]); err != nil {
				return
			}
			p += lDateOfBirth
		}
	}
	// Parents
	for i0 := 0; i0 < 2; i0++ {
		{
			var p010 *person
			if p++; data[p-1] != 0 {
				v110 := person{}
				if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
					return
				}
				p010 = &v110
			}
			me.Parents[i0] = p010
		}
	}
	// FavPet
	{
		t := data[p]
		p++
		switch t {
		case 1:
			var u *petCat
			{
				var p000 *petCat
				if p++; data[p-1] != 0 {
					v100 := petCat{}
					if err = v100.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 2:
			var u *petDog
			{
				var p000 *petDog
				if p++; data[p-1] != 0 {
					v100 := petDog{}
					if err = v100.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 3:
			var u *petHamster
			{
				var p000 *petHamster
				if p++; data[p-1] != 0 {
					v100 := petHamster{}
					if err = v100.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 4:
			var u *petPiranha
			{
				var p000 *petPiranha
				if p++; data[p-1] != 0 {
					v100 := petPiranha{}
					if err = v100.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		default:
			me.FavPet = nil
		}
	}
	// Top5Hobbies
	for i0 := 0; i0 < 5; i0++ {
		if err = me.Top5Hobbies[i0].unmarshalFrom(&p, data, addrs); err != nil {
			return
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *person) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *person) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 11925296559860657288 {
			err = errors.New("person: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *person) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((8 + len(me.FirstName)) + 72) + 8) + 18) + 8) + 385)))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{11925296559860657288, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* pet:
   6 field(s)

   The serialization view:
   - DailyFoodBill - float32, 4b, begins fixed-size span of ~20b (+padding/alignment..) over the next 2 field(s)
   - AgeWhenAdopted - int64, 8b
   - LastIllness.Days - int64, 8b
   - LastIllness.Date - *time.Time
   - LastIllness.Notes - []string
   - OrigCostIfKnown - *complex128
*/

func (me *pet) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// DailyFoodBill, AgeWhenAdopted, LastIllness.Days
	buf.Write((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))[:])
	// LastIllness.Date
	if me.LastIllness.Date == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		{
			d, e := me.LastIllness.Date.MarshalBinary()
			if err = e; err != nil {
				return
			}
			lLastIllnessDate := (len(d))
			buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessDate))[:])
			buf.Write(d)
		}
	}
	// LastIllness.Notes
	{
		lLastIllnessNotes := (len(me.LastIllness.Notes))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessNotes))[:])
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (len(me.LastIllness.Notes[i0]))
			buf.Write((*[8]byte)(unsafe.Pointer(&li0))[:])
			buf.WriteString(me.LastIllness.Notes[i0])
		}
	}
	// OrigCostIfKnown
	if me.OrigCostIfKnown == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		buf.Write(((*[16]byte)(unsafe.Pointer(me.OrigCostIfKnown)))[:])
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *pet) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *pet) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// DailyFoodBill, AgeWhenAdopted, LastIllness.Days
	*((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))) = *((*[20]byte)(unsafe.Pointer(&data[p])))
	p += 20
	// LastIllness.Date
	{
		var p000 *time.Time
		if p++; data[p-1] != 0 {
			v100 := time.Time{}
			{
				lLastIllnessDate := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				if lLastIllnessDate > 0 {
					if err = v100.UnmarshalBinary(data[p : p+lLastIllnessDate]); err != nil {
						return
					}
					p += lLastIllnessDate
				}
			}
			p000 = &v100
		}
		me.LastIllness.Date = p000
	}
	// LastIllness.Notes
	{
		lLastIllnessNotes := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.LastIllness.Notes = make([]string, lLastIllnessNotes)
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			me.LastIllness.Notes[i0] = string(data[p : p+li0])
			p += li0
		}
	}
	// OrigCostIfKnown
	{
		var p000 *complex128
		if p++; data[p-1] != 0 {
			v100 := *((*complex128)(unsafe.Pointer(&data[p])))
			p += 16
			p000 = &v100
		}
		me.OrigCostIfKnown = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *pet) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *pet) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 13186359848934745181 {
			err = errors.New("pet: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *pet) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{13186359848934745181, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petCat:
   2 field(s)

   The serialization view:
   - pet - pet
   - RabbitsSlaynPerDayOnAvg - *uint8
*/

func (me *petCat) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// pet
	if err = me.pet.marshalTo(buf, addrs); err != nil {
		return
	}
	// RabbitsSlaynPerDayOnAvg
	if me.RabbitsSlaynPerDayOnAvg == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		buf.WriteByte((*me.RabbitsSlaynPerDayOnAvg))
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *petCat) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 2)))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petCat) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// pet
	if err = me.pet.unmarshalFrom(&p, data, addrs); err != nil {
		return
	}
	// RabbitsSlaynPerDayOnAvg
	{
		var p000 *uint8
		if p++; data[p-1] != 0 {
			v100 := data[p]
			p++
			p000 = &v100
		}
		me.RabbitsSlaynPerDayOnAvg = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *petCat) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *petCat) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 13481110904349996911 {
			err = errors.New("petCat: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *petCat) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 2)))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{13481110904349996911, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petDog:
   2 field(s)

   The serialization view:
   - pet - pet
   - WalkLog - *map[*time.Time][7]time.Duration
*/

func (me *petDog) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// pet
	if err = me.pet.marshalTo(buf, addrs); err != nil {
		return
	}
	// WalkLog
	if me.WalkLog == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.WalkLog
		{
			lWalkLog := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lWalkLog))[:])
			for k0, m0 := range pv000 {
				if k0 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					{
						d, e := k0.MarshalBinary()
						if err = e; err != nil {
							return
						}
						lk0 := (len(d))
						buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
						buf.Write(d)
					}
				}
				buf.Write(((*[56]byte)(unsafe.Pointer(&(m0[0]))))[:])
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *petDog) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 139)))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petDog) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// pet
	if err = me.pet.unmarshalFrom(&p, data, addrs); err != nil {
		return
	}
	// WalkLog
	{
		var p000 *map[*time.Time][7]time.Duration
		if p++; data[p-1] != 0 {
			lWalkLog := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := make(map[*time.Time][7]time.Duration, lWalkLog)
			for i0 := 0; i0 < (lWalkLog); i0++ {
				var bk0 *time.Time
				var bm0 [7]time.Duration
				{
					var p010 *time.Time
					if p++; data[p-1] != 0 {
						v110 := time.Time{}
						{
							lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
							p += 8
							if lk0 > 0 {
								if err = v110.UnmarshalBinary(data[p : p+lk0]); err != nil {
									return
								}
								p += lk0
							}
						}
						p010 = &v110
					}
					bk0 = p010
				}
				bm0 = *((*[7]time.Duration)(unsafe.Pointer(&data[p])))
				p += 56
				v100[bk0] = bm0
			}
			p000 = &v100
		}
		me.WalkLog = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *petDog) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *petDog) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 3596748310628763049 {
			err = errors.New("petDog: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *petDog) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 139)))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{3596748310628763049, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petHamster:
   1 field(s)

   The serialization view:
   - pet - pet
*/

func (me *petHamster) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// pet
	if err = me.pet.marshalTo(buf, addrs); err != nil {
		return
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *petHamster) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petHamster) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// pet
	if err = me.pet.unmarshalFrom(&p, data, addrs); err != nil {
		return
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *petHamster) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *petHamster) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 13333275131017623849 {
			err = errors.New("petHamster: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *petHamster) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{13333275131017623849, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petPiranha:
   2 field(s)

   The serialization view:
   - pet - pet
   - Weird - map[*[2048]byte][]fixedSize
*/

func (me *petPiranha) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// pet
	if err = me.pet.marshalTo(buf, addrs); err != nil {
		return
	}
	// Weird
	{
		lWeird := (len(me.Weird))
		buf.Write((*[8]byte)(unsafe.Pointer(&lWeird))[:])
		for k0, m0 := range me.Weird {
			if k0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				buf.Write(((*[2048]byte)(unsafe.Pointer(k0)))[:])
			}
			lm0 := (len(m0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lm0))[:])
			if (lm0) > 0 && (lm0) < 634600 {
				buf.Write((*[2147483647]byte)(unsafe.Pointer(&m0[0]))[:3384*(lm0)])
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					buf.Write((*[3384]byte)(unsafe.Pointer(&m0[i1]))[:])
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *petPiranha) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + (8 + ((len(me.Weird) * 2049) + (len(me.Weird) * 6776))))))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petPiranha) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// pet
	if err = me.pet.unmarshalFrom(&p, data, addrs); err != nil {
		return
	}
	// Weird
	{
		lWeird := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Weird = make(map[*[2048]byte][]fixedSize, lWeird)
		for i0 := 0; i0 < (lWeird); i0++ {
			var bk0 *[2048]byte
			var bm0 []fixedSize
			{
				var p010 *[2048]byte
				if p++; data[p-1] != 0 {
					v110 := *((*[2048]byte)(unsafe.Pointer(&data[p])))
					p += 2048
					p010 = &v110
				}
				bk0 = p010
			}
			lm0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bm0 = make([]fixedSize, lm0)
			if (lm0) > 0 && (lm0) < 634600 {
				lmul := 3384 * (lm0)
				copy(((*[2147483647]byte)(unsafe.Pointer(&bm0[0])))[0:lmul], data[p:p+(lmul)])
				p += (lmul)
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					bm0[i1] = *((*fixedSize)(unsafe.Pointer(&data[p])))
					p += 3384
				}
			}
			me.Weird[bk0] = bm0
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *petPiranha) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *petPiranha) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 11146996824496730984 {
			err = errors.New("petPiranha: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *petPiranha) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + (8 + ((len(me.Weird) * 2049) + (len(me.Weird) * 6776))))))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{11146996824496730984, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* school:
   2 field(s)

   The serialization view:
   - Teachers - []*person
   - Pupils - []*person
*/

func (me *school) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// Teachers
	{
		lTeachers := (len(me.Teachers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lTeachers))[:])
		for i0 := 0; i0 < (lTeachers); i0++ {
			if me.Teachers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = me.Teachers[i0].marshalTo(buf, addrs); err != nil {
					return
				}
			}
		}
	}
	// Pupils
	{
		lPupils := (len(me.Pupils))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPupils))[:])
		for i0 := 0; i0 < (lPupils); i0++ {
			if me.Pupils[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = me.Pupils[i0].marshalTo(buf, addrs); err != nil {
					return
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *school) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + (len(me.Teachers) * 507)) + (8 + (len(me.Pupils) * 507)))))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *school) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// Teachers
	{
		lTeachers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Teachers = make([]*person, lTeachers)
		for i0 := 0; i0 < (lTeachers); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p010 = &v110
				}
				me.Teachers[i0] = p010
			}
		}
	}
	// Pupils
	{
		lPupils := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Pupils = make([]*person, lPupils)
		for i0 := 0; i0 < (lPupils); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data, addrs); err != nil {
						return
					}
					p010 = &v110
				}
				me.Pupils[i0] = p010
			}
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *school) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *school) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 11190834307079325616 {
			err = errors.New("school: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *school) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + (len(me.Teachers) * 507)) + (8 + (len(me.Pupils) * 507)))))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{11190834307079325616, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* simWorld:
   1 field(s)

   The serialization view:
   - Cities - [123]city
*/

func (me *simWorld) marshalTo(buf *bytes.Buffer, addrs map[uintptr]uint64) (err error) {
	// Cities
	for i0 := 0; i0 < 123; i0++ {
		if err = me.Cities[i0].marshalTo(buf, addrs); err != nil {
			return
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (me *simWorld) MarshalBinary() (data []byte, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 791874))
	if err = me.marshalTo(buf, addrs); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *simWorld) unmarshalFrom(pos *int, data []byte, addrs map[uint64]uintptr) (err error) {
	p := *pos
	// Cities
	for i0 := 0; i0 < 123; i0++ {
		if err = me.Cities[i0].unmarshalFrom(&p, data, addrs); err != nil {
			return
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (me *simWorld) UnmarshalBinary(data []byte) (err error) {
	var addrs = map[uint64]uintptr{}
	var pos0 int
	err = me.unmarshalFrom(&pos0, data, addrs)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (me *simWorld) ReadFrom(r io.Reader) (int64, error) {
	var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 8840850003979738572 {
			err = errors.New("simWorld: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = me.unmarshalFrom(&pos0, data, addrs)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (me *simWorld) WriteTo(w io.Writer) (n int64, err error) {
	var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 791874))
	if err = me.marshalTo(buf, addrs); err == nil {
		header := [2]uint64{8840850003979738572, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}
