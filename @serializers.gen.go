package main

// Code generated by github.com/metaleap/gogen-dump â€” DO NOT EDIT.

// This file consists solely of generated (de)serialization methods for these 7 struct types:
// - fixedSize
// - hobby
// - person
// - pet
// - petCat
// - petDog
// - petPiranha

import (
	"bytes"
	"io"
	"unsafe"

	time "time"
)

func (me *fixedSize) marshalTo(buf *bytes.Buffer) (err error) {

	buf.Write((*[3384]byte)(unsafe.Pointer(me))[:])

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *fixedSize) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *fixedSize) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *fixedSize) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	*me = *((*fixedSize)(unsafe.Pointer(&data[p])))
	p += 3384

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *fixedSize) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *fixedSize) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *hobby) marshalTo(buf *bytes.Buffer) (err error) {

	lName := (len(me.Name))
	buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
	buf.WriteString(me.Name)

	buf.Write((*[23]byte)(unsafe.Pointer(&me.Outdoorsy))[:])

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *hobby) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.Name))+1+16+4+2))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *hobby) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *hobby) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	lName := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.Name = string(data[p : p+lName])
	p += lName

	*((*[23]byte)(unsafe.Pointer(&me.Outdoorsy))) = *((*[23]byte)(unsafe.Pointer(&data[p])))
	p += 23

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *hobby) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *hobby) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.Name))+1+16+4+2))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *person) marshalTo(buf *bytes.Buffer) (err error) {

	lFirstName := (len(me.FirstName))
	buf.Write((*[8]byte)(unsafe.Pointer(&lFirstName))[:])
	buf.WriteString(me.FirstName)

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *person) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8 + len(me.FirstName))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *person) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *person) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	lFirstName := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.FirstName = string(data[p : p+lFirstName])
	p += lFirstName

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *person) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *person) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8 + len(me.FirstName))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *pet) marshalTo(buf *bytes.Buffer) (err error) {

	buf.Write((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))[:])

	{
		d, e := me.LastIllness.Date.MarshalBinary()
		if err = e; err != nil {
			return
		}
		lLastIllnessDate := (len(d))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessDate))[:])
		buf.Write(d)
	}

	lLastIllnessNotes := (len(me.LastIllness.Notes))
	buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessNotes))[:])
	for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
		li0 := (len(me.LastIllness.Notes[i0]))
		buf.Write((*[8]byte)(unsafe.Pointer(&li0))[:])
		buf.WriteString(me.LastIllness.Notes[i0])
	}

	if me.OrigCostIfKnown == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv00 := *me.OrigCostIfKnown
		buf.Write(((*[16]byte)(unsafe.Pointer(&(pv00))))[:])
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *pet) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.LastIllness.Notes)*(8+44)))+(1+16)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *pet) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *pet) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	*((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))) = *((*[20]byte)(unsafe.Pointer(&data[p])))
	p += 20

	lLastIllnessDate := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	if lLastIllnessDate > 0 {
		if err = me.LastIllness.Date.UnmarshalBinary(data[p : p+lLastIllnessDate]); err != nil {
			return
		}
		p += lLastIllnessDate
	}

	lLastIllnessNotes := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.LastIllness.Notes = make([]string, lLastIllnessNotes)
	for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
		li0 := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.LastIllness.Notes[i0] = string(data[p : p+li0])
		p += li0
	}

	{
		var p00 *complex128
		if p++; data[p-1] != 0 {
			v10 := *((*complex128)(unsafe.Pointer(&data[p])))
			p += 16
			p00 = &v10
		}
		me.OrigCostIfKnown = p00
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *pet) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *pet) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.LastIllness.Notes)*(8+44)))+(1+16)))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *petCat) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	if me.RabbitsSlaynPerDayOnAvg == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv00 := *me.RabbitsSlaynPerDayOnAvg
		buf.WriteByte(pv00)
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petCat) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(1+1)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petCat) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *petCat) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	{
		var p00 *uint8
		if p++; data[p-1] != 0 {
			v10 := data[p]
			p++
			p00 = &v10
		}
		me.RabbitsSlaynPerDayOnAvg = p00
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petCat) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petCat) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(1+1)))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *petDog) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	lWalkLog := (len(me.WalkLog))
	buf.Write((*[8]byte)(unsafe.Pointer(&lWalkLog))[:])
	for k0, m0 := range me.WalkLog {
		{
			d, e := k0.MarshalBinary()
			if err = e; err != nil {
				return
			}
			lk0 := (len(d))
			buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
			buf.Write(d)
		}
		buf.Write(((*[56]byte)(unsafe.Pointer(&(m0[0]))))[:])
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petDog) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(8+(len(me.WalkLog)*234)+(len(me.WalkLog)*(7*8)))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petDog) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *petDog) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	lWalkLog := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.WalkLog = make(map[time.Time][7]time.Duration, lWalkLog)
	for i0 := 0; i0 < (lWalkLog); i0++ {
		var bk0 time.Time
		var bm0 [7]time.Duration
		lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		if lk0 > 0 {
			if err = bk0.UnmarshalBinary(data[p : p+lk0]); err != nil {
				return
			}
			p += lk0
		}
		bm0 = *((*[7]time.Duration)(unsafe.Pointer(&data[p])))
		p += 56
		me.WalkLog[bk0] = bm0
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petDog) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petDog) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(8+(len(me.WalkLog)*234)+(len(me.WalkLog)*(7*8)))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *petPiranha) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	lWeird := (len(me.Weird))
	buf.Write((*[8]byte)(unsafe.Pointer(&lWeird))[:])
	for k0, m0 := range me.Weird {
		if k0 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv01 := *k0
			buf.Write(((*[2048]byte)(unsafe.Pointer(&(pv01[0]))))[:])
		}
		lm0 := (len(m0))
		buf.Write((*[8]byte)(unsafe.Pointer(&lm0))[:])
		if (lm0) > 0 && (lm0) < 634600 {
			buf.Write((*[2147483647]byte)(unsafe.Pointer(&m0[0]))[:3384*(lm0)])
		} else {
			for i1 := 0; i1 < (lm0); i1++ {
				buf.Write((*[3384]byte)(unsafe.Pointer(&m0[i1]))[:])
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petPiranha) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(8+(len(me.Weird)*(1+(2048*1)))+(len(me.Weird)*(8+(33*3384))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petPiranha) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *petPiranha) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	lWeird := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.Weird = make(map[*[2048]byte][]fixedSize, lWeird)
	for i0 := 0; i0 < (lWeird); i0++ {
		var bk0 *[2048]byte
		var bm0 []fixedSize
		{
			var p01 *[2048]byte
			if p++; data[p-1] != 0 {
				v11 := *((*[2048]byte)(unsafe.Pointer(&data[p])))
				p += 2048
				p01 = &v11
			}
			bk0 = p01
		}
		lm0 := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		bm0 = make([]fixedSize, lm0)
		if (lm0) > 0 && (lm0) < 634600 {
			lmul := 3384 * (lm0)
			copy(((*[2147483647]byte)(unsafe.Pointer(&bm0[0])))[0:lmul], data[p:p+(lmul)])
			p += (lmul)
		} else {
			for i1 := 0; i1 < (lm0); i1++ {
				bm0[i1] = *((*fixedSize)(unsafe.Pointer(&data[p])))
				p += 3384
			}
		}
		me.Weird[bk0] = bm0
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petPiranha) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petPiranha) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+234+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(8+(len(me.Weird)*(1+(2048*1)))+(len(me.Weird)*(8+(33*3384))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}
