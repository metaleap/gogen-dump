package main

// Code generated by github.com/metaleap/gogen-dump — DO NOT EDIT.

import (
	"bytes"
	"io"
	"unsafe"

	fmt "fmt"
)

func (me *fixed) writeTo(buf *bytes.Buffer) (err error) {

	buf.Write((*[2036]byte)(unsafe.Pointer(me))[:])

	return
}

func (me *fixed) WriteTo(w io.Writer) (int64, error) {
	var buf bytes.Buffer
	if err := me.writeTo(&buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *fixed) MarshalBinary() (data []byte, err error) {
	var buf bytes.Buffer
	if err = me.writeTo(&buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *fixed) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *fixed) UnmarshalBinary(data []byte) (err error) {

	*me = *((*fixed)(unsafe.Pointer(&data[0])))

	return
}

func (me *testStruct) writeTo(buf *bytes.Buffer) (err error) {

	var data bytes.Buffer

	if err = me.embName.writeTo(&data); err != nil {
		return
	}
	l_embName := (data.Len())
	buf.Write((*[8]byte)(unsafe.Pointer(&l_embName))[:])
	data.WriteTo(buf)

	buf.Write(((*[16]byte)(unsafe.Pointer(&(me.DingDong.Complex))))[:])

	buf.Write(((*[504]byte)(unsafe.Pointer(&(me.DingDong.FixedSize[0]))))[:])

	if me.Hm.Balance == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		for i_HmꓸBalance := 0; i_HmꓸBalance < 3; i_HmꓸBalance++ {
			if (*me.Hm.Balance)[i_HmꓸBalance] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if *(*me.Hm.Balance)[i_HmꓸBalance] == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					buf.Write(((*[2]byte)(unsafe.Pointer(*(*me.Hm.Balance)[i_HmꓸBalance])))[:])
				}
			}
		}
	}

	buf.Write(((*[8]byte)(unsafe.Pointer(&(me.Hm.Hm.AccountAge))))[:])

	l_HmꓸHmꓸLookie := (len(me.Hm.Hm.Lookie))
	buf.Write((*[8]byte)(unsafe.Pointer(&l_HmꓸHmꓸLookie))[:])
	if (l_HmꓸHmꓸLookie) > 0 {
		buf.Write((*[1125899906842623]byte)(unsafe.Pointer(&me.Hm.Hm.Lookie[0]))[:2036*(l_HmꓸHmꓸLookie)])
	}

	l_HmꓸHmꓸAny := (len(me.Hm.Hm.Any))
	buf.Write((*[8]byte)(unsafe.Pointer(&l_HmꓸHmꓸAny))[:])
	for k0, m0 := range me.Hm.Hm.Any {
		if k0 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			buf.Write((*[2036]byte)(unsafe.Pointer(k0))[:])
		}
		{
			switch t := m0.(type) {
			case fixed:
				buf.WriteByte(1)
				buf.Write((*[2036]byte)(unsafe.Pointer(&t))[:])
			case *fixed:
				buf.WriteByte(2)
				if t == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					buf.Write((*[2036]byte)(unsafe.Pointer(t))[:])
				}
			case []fixed:
				buf.WriteByte(3)
				l_m0 := (len(t))
				buf.Write((*[8]byte)(unsafe.Pointer(&l_m0))[:])
				if (l_m0) > 0 {
					buf.Write((*[1125899906842623]byte)(unsafe.Pointer(&t[0]))[:2036*(l_m0)])
				}
			case [5][6]fixed:
				buf.WriteByte(4)
				buf.Write(((*[61080]byte)(unsafe.Pointer(&(t[0]))))[:])
			case *embName:
				buf.WriteByte(5)
				if t == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					if err = t.writeTo(&data); err != nil {
						return
					}
					l_m0 := (data.Len())
					buf.Write((*[8]byte)(unsafe.Pointer(&l_m0))[:])
					data.WriteTo(buf)
				}
			case []embName:
				buf.WriteByte(6)
				l_m0 := (len(t))
				buf.Write((*[8]byte)(unsafe.Pointer(&l_m0))[:])
				for i_m0 := 0; i_m0 < (l_m0); i_m0++ {
					if err = t[i_m0].writeTo(&data); err != nil {
						return
					}
					l_i_m0 := (data.Len())
					buf.Write((*[8]byte)(unsafe.Pointer(&l_i_m0))[:])
					data.WriteTo(buf)
				}
			case []*embName:
				buf.WriteByte(7)
				l_m0 := (len(t))
				buf.Write((*[8]byte)(unsafe.Pointer(&l_m0))[:])
				for i_m0 := 0; i_m0 < (l_m0); i_m0++ {
					if t[i_m0] == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						if err = t[i_m0].writeTo(&data); err != nil {
							return
						}
						l_i_m0 := (data.Len())
						buf.Write((*[8]byte)(unsafe.Pointer(&l_i_m0))[:])
						data.WriteTo(buf)
					}
				}
			case []*float32:
				buf.WriteByte(8)
				l_m0 := (len(t))
				buf.Write((*[8]byte)(unsafe.Pointer(&l_m0))[:])
				for i_m0 := 0; i_m0 < (l_m0); i_m0++ {
					if t[i_m0] == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						buf.Write(((*[4]byte)(unsafe.Pointer(t[i_m0])))[:])
					}
				}
			case nil:
				buf.WriteByte(0)
			default:
				return fmt.Errorf("testStruct.m0: type %T not mentioned in tagged-union field-tag", t)
			}
		}
	}

	l_HmꓸFoo := (len(me.Hm.Foo))
	buf.Write((*[8]byte)(unsafe.Pointer(&l_HmꓸFoo))[:])
	for i_HmꓸFoo := 0; i_HmꓸFoo < (l_HmꓸFoo); i_HmꓸFoo++ {
		for i_i_HmꓸFoo := 0; i_i_HmꓸFoo < 2; i_i_HmꓸFoo++ {
			l_i_i_HmꓸFoo := (len(me.Hm.Foo[i_HmꓸFoo][i_i_HmꓸFoo]))
			buf.Write((*[8]byte)(unsafe.Pointer(&l_i_i_HmꓸFoo))[:])
			for k2, m2 := range me.Hm.Foo[i_HmꓸFoo][i_i_HmꓸFoo] {
				buf.Write(((*[4]byte)(unsafe.Pointer(&(k2))))[:])
				if m2 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					if *m2 == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						if **m2 == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							l_m2 := (len((***m2)))
							buf.Write((*[8]byte)(unsafe.Pointer(&l_m2))[:])
							for i_m2 := 0; i_m2 < (l_m2); i_m2++ {
								if (***m2)[i_m2] == nil {
									buf.WriteByte(0)
								} else {
									buf.WriteByte(1)
									buf.Write(((*[2]byte)(unsafe.Pointer((***m2)[i_m2])))[:])
								}
							}
						}
					}
				}
			}
		}
	}

	if me.Age == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		if *me.Age == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			if **me.Age == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if ***me.Age == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					buf.Write(((*[8]byte)(unsafe.Pointer(***me.Age)))[:])
				}
			}
		}
	}

	return
}

func (me *testStruct) WriteTo(w io.Writer) (int64, error) {
	var buf bytes.Buffer
	if err := me.writeTo(&buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *testStruct) MarshalBinary() (data []byte, err error) {
	var buf bytes.Buffer
	if err = me.writeTo(&buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *testStruct) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *testStruct) UnmarshalBinary(data []byte) (err error) {

	var p int

	l_embName := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	if err = me.embName.UnmarshalBinary(data[p : p+l_embName]); err != nil {
		return
	}
	p += l_embName

	me.DingDong.Complex = *((*complex128)(unsafe.Pointer(&data[p])))
	p += 16

	me.DingDong.FixedSize = *((*[9][7]float64)(unsafe.Pointer(&data[p])))
	p += 504

	{
		var p0 *[3]**int16
		if p++; data[p-1] != 0 {
			vHmꓸBalance := [3]**int16{}
			for i_HmꓸBalance := 0; i_HmꓸBalance < 3; i_HmꓸBalance++ {
				{
					var p0 **int16
					var p1 *int16
					if p++; data[p-1] != 0 {
						if p++; data[p-1] != 0 {
							vi_HmꓸBalance := *((*int16)(unsafe.Pointer(&data[p])))
							p += 2
							p1 = &vi_HmꓸBalance
						}
						p0 = &p1
					}
					vHmꓸBalance[i_HmꓸBalance] = p0
				}
			}
			p0 = &vHmꓸBalance
		}
		me.Hm.Balance = p0
	}

	me.Hm.Hm.AccountAge = *((*int)(unsafe.Pointer(&data[p])))
	p += 8

	l_HmꓸHmꓸLookie := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.Hm.Hm.Lookie = make([]fixed, l_HmꓸHmꓸLookie)
	if (l_HmꓸHmꓸLookie) > 0 {
		copy(((*[1125899906842623]byte)(unsafe.Pointer(&me.Hm.Hm.Lookie[0])))[0:2036*(l_HmꓸHmꓸLookie)], data[p:p+(2036*(l_HmꓸHmꓸLookie))])
		p += (2036 * (l_HmꓸHmꓸLookie))
	}

	l_HmꓸHmꓸAny := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.Hm.Hm.Any = make(map[*fixed]iface1, l_HmꓸHmꓸAny)
	for i_HmꓸHmꓸAny := 0; i_HmꓸHmꓸAny < (l_HmꓸHmꓸAny); i_HmꓸHmꓸAny++ {
		var bk0 *fixed
		var bm0 iface1
		{
			var p0 *fixed
			if p++; data[p-1] != 0 {
				vk0 := *((*fixed)(unsafe.Pointer(&data[p])))
				p += 2036
				p0 = &vk0
			}
			bk0 = p0
		}
		{
			t := data[p]
			p++
			switch t {
			case 1:
				var u fixed
				u = *((*fixed)(unsafe.Pointer(&data[p])))
				p += 2036
				bm0 = u
			case 2:
				var u *fixed
				{
					var p0 *fixed
					if p++; data[p-1] != 0 {
						vm0 := *((*fixed)(unsafe.Pointer(&data[p])))
						p += 2036
						p0 = &vm0
					}
					u = p0
				}
				bm0 = u
			case 3:
				var u []fixed
				l_m0 := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				u = make([]fixed, l_m0)
				if (l_m0) > 0 {
					copy(((*[1125899906842623]byte)(unsafe.Pointer(&u[0])))[0:2036*(l_m0)], data[p:p+(2036*(l_m0))])
					p += (2036 * (l_m0))
				}
				bm0 = u
			case 4:
				var u [5][6]fixed
				u = *((*[5][6]fixed)(unsafe.Pointer(&data[p])))
				p += 61080
				bm0 = u
			case 5:
				var u *embName
				{
					var p0 *embName
					if p++; data[p-1] != 0 {
						vm0 := embName{}
						l_m0 := (*((*int)(unsafe.Pointer(&data[p]))))
						p += 8
						if err = vm0.UnmarshalBinary(data[p : p+l_m0]); err != nil {
							return
						}
						p += l_m0
						p0 = &vm0
					}
					u = p0
				}
				bm0 = u
			case 6:
				var u []embName
				l_m0 := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				u = make([]embName, l_m0)
				for i_m0 := 0; i_m0 < (l_m0); i_m0++ {
					l_i_m0 := (*((*int)(unsafe.Pointer(&data[p]))))
					p += 8
					if err = u[i_m0].UnmarshalBinary(data[p : p+l_i_m0]); err != nil {
						return
					}
					p += l_i_m0
				}
				bm0 = u
			case 7:
				var u []*embName
				l_m0 := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				u = make([]*embName, l_m0)
				for i_m0 := 0; i_m0 < (l_m0); i_m0++ {
					{
						var p0 *embName
						if p++; data[p-1] != 0 {
							vi_m0 := embName{}
							l_i_m0 := (*((*int)(unsafe.Pointer(&data[p]))))
							p += 8
							if err = vi_m0.UnmarshalBinary(data[p : p+l_i_m0]); err != nil {
								return
							}
							p += l_i_m0
							p0 = &vi_m0
						}
						u[i_m0] = p0
					}
				}
				bm0 = u
			case 8:
				var u []*float32
				l_m0 := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				u = make([]*float32, l_m0)
				for i_m0 := 0; i_m0 < (l_m0); i_m0++ {
					{
						var p0 *float32
						if p++; data[p-1] != 0 {
							vi_m0 := *((*float32)(unsafe.Pointer(&data[p])))
							p += 4
							p0 = &vi_m0
						}
						u[i_m0] = p0
					}
				}
				bm0 = u
			default:
				bm0 = nil
			}
		}
		me.Hm.Hm.Any[bk0] = bm0
	}

	l_HmꓸFoo := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.Hm.Foo = make([][2]map[rune]***[]*int16, l_HmꓸFoo)
	for i_HmꓸFoo := 0; i_HmꓸFoo < (l_HmꓸFoo); i_HmꓸFoo++ {
		for i_i_HmꓸFoo := 0; i_i_HmꓸFoo < 2; i_i_HmꓸFoo++ {
			l_i_i_HmꓸFoo := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			me.Hm.Foo[i_HmꓸFoo][i_i_HmꓸFoo] = make(map[rune]***[]*int16, l_i_i_HmꓸFoo)
			for i_i_i_HmꓸFoo := 0; i_i_i_HmꓸFoo < (l_i_i_HmꓸFoo); i_i_i_HmꓸFoo++ {
				var bk2 rune
				var bm2 ***[]*int16
				bk2 = *((*rune)(unsafe.Pointer(&data[p])))
				p += 4
				{
					var p0 ***[]*int16
					var p1 **[]*int16
					var p2 *[]*int16
					if p++; data[p-1] != 0 {
						if p++; data[p-1] != 0 {
							if p++; data[p-1] != 0 {
								l_m2 := (*((*int)(unsafe.Pointer(&data[p]))))
								p += 8
								vm2 := make([]*int16, l_m2)
								for i_m2 := 0; i_m2 < (l_m2); i_m2++ {
									{
										var p0 *int16
										if p++; data[p-1] != 0 {
											vi_m2 := *((*int16)(unsafe.Pointer(&data[p])))
											p += 2
											p0 = &vi_m2
										}
										vm2[i_m2] = p0
									}
								}
								p2 = &vm2
							}
							p1 = &p2
						}
						p0 = &p1
					}
					bm2 = p0
				}
				me.Hm.Foo[i_HmꓸFoo][i_i_HmꓸFoo][bk2] = bm2
			}
		}
	}

	{
		var p0 ****uint
		var p1 ***uint
		var p2 **uint
		var p3 *uint
		if p++; data[p-1] != 0 {
			if p++; data[p-1] != 0 {
				if p++; data[p-1] != 0 {
					if p++; data[p-1] != 0 {
						vAge := *((*uint)(unsafe.Pointer(&data[p]))) /* p += 8 */
						p3 = &vAge
					}
					p2 = &p3
				}
				p1 = &p2
			}
			p0 = &p1
		}
		me.Age = p0
	}

	return
}

func (me *embName) writeTo(buf *bytes.Buffer) (err error) {

	buf.Write(((*[24432]byte)(unsafe.Pointer(&(me.LeFix[0]))))[:])

	l_FirstName := (len(me.FirstName))
	buf.Write((*[8]byte)(unsafe.Pointer(&l_FirstName))[:])
	buf.WriteString(me.FirstName)

	l_MiddleNames := (len(me.MiddleNames))
	buf.Write((*[8]byte)(unsafe.Pointer(&l_MiddleNames))[:])
	for i_MiddleNames := 0; i_MiddleNames < (l_MiddleNames); i_MiddleNames++ {
		if me.MiddleNames[i_MiddleNames] == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			if *me.MiddleNames[i_MiddleNames] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if **me.MiddleNames[i_MiddleNames] == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					for i_i_MiddleNames := 0; i_i_MiddleNames < 5; i_i_MiddleNames++ {
						if (***me.MiddleNames[i_MiddleNames])[i_i_MiddleNames] == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							l_i_i_MiddleNames := (len((*(***me.MiddleNames[i_MiddleNames])[i_i_MiddleNames])))
							buf.Write((*[8]byte)(unsafe.Pointer(&l_i_i_MiddleNames))[:])
							buf.WriteString((*(***me.MiddleNames[i_MiddleNames])[i_i_MiddleNames]))
						}
					}
				}
			}
		}
	}

	if me.LastName == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		if *me.LastName == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			l_LastName := (len((**me.LastName)))
			buf.Write((*[8]byte)(unsafe.Pointer(&l_LastName))[:])
			buf.WriteString((**me.LastName))
		}
	}

	return
}

func (me *embName) WriteTo(w io.Writer) (int64, error) {
	var buf bytes.Buffer
	if err := me.writeTo(&buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

func (me *embName) MarshalBinary() (data []byte, err error) {
	var buf bytes.Buffer
	if err = me.writeTo(&buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *embName) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *embName) UnmarshalBinary(data []byte) (err error) {

	var p int

	me.LeFix = *((*[3][4]fixed)(unsafe.Pointer(&data[p])))
	p += 24432

	l_FirstName := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.FirstName = string(data[p : p+l_FirstName])
	p += l_FirstName

	l_MiddleNames := (*((*int)(unsafe.Pointer(&data[p]))))
	p += 8
	me.MiddleNames = make([]***[5]*string, l_MiddleNames)
	for i_MiddleNames := 0; i_MiddleNames < (l_MiddleNames); i_MiddleNames++ {
		{
			var p0 ***[5]*string
			var p1 **[5]*string
			var p2 *[5]*string
			if p++; data[p-1] != 0 {
				if p++; data[p-1] != 0 {
					if p++; data[p-1] != 0 {
						vi_MiddleNames := [5]*string{}
						for i_i_MiddleNames := 0; i_i_MiddleNames < 5; i_i_MiddleNames++ {
							{
								var p0 *string
								if p++; data[p-1] != 0 {
									l_i_i_MiddleNames := (*((*int)(unsafe.Pointer(&data[p]))))
									p += 8
									vi_i_MiddleNames := string(data[p : p+l_i_i_MiddleNames])
									p += l_i_i_MiddleNames
									p0 = &vi_i_MiddleNames
								}
								vi_MiddleNames[i_i_MiddleNames] = p0
							}
						}
						p2 = &vi_MiddleNames
					}
					p1 = &p2
				}
				p0 = &p1
			}
			me.MiddleNames[i_MiddleNames] = p0
		}
	}

	{
		var p0 **string
		var p1 *string
		if p++; data[p-1] != 0 {
			if p++; data[p-1] != 0 {
				l_LastName := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				vLastName := string(data[p : p+l_LastName]) /* p += l_LastName */
				p1 = &vLastName
			}
			p0 = &p1
		}
		me.LastName = p0
	}

	return
}
