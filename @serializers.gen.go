package main

// Code generated by github.com/metaleap/gogen-dump - DO NOT EDIT.

// This file consists solely of generated (de)serialization methods for these 13 struct types:
// - city
// - company
// - family
// - fixedSize
// - hobby
// - person
// - pet
// - petCat
// - petDog
// - petHamster
// - petPiranha
// - school
// - simWorld

import (
	"bytes"
	"io"
	"unsafe"

	time "time"
)

/* city:
   5 field(s)

   The serialization view:
   - Name - string
   - ClosestTo - *city
   - Companies - []company
   - Families - *[]family
   - Schools - *[]*school
*/

func (me *city) structVersion() uint64 {
	return 11068290357372428015
}

func (me *city) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lName := (len(me.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(me.Name)
	}

	if me.ClosestTo == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.ClosestTo
		if err = pv000.marshalTo(buf); err != nil {
			return
		}
	}

	{
		lCompanies := (len(me.Companies))
		buf.Write((*[8]byte)(unsafe.Pointer(&lCompanies))[:])
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = me.Companies[i0].marshalTo(buf); err != nil {
				return
			}
		}
	}

	if me.Families == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Families
		{
			lFamilies := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lFamilies))[:])
			for i0 := 0; i0 < (lFamilies); i0++ {
				if err = pv000[i0].marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	if me.Schools == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Schools
		{
			lSchools := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lSchools))[:])
			for i0 := 0; i0 < (lSchools); i0++ {
				if pv000[i0] == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					pv010 := *pv000[i0]
					if err = pv010.marshalTo(buf); err != nil {
						return
					}
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *city) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.Name))+(1+234)+(8+(len(me.Companies)*(8+(33*(1+234)))+(8+(33*(1+234)))+(8+(33*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))+(1+(8+(33*(8+44)+(8+(22*(8+44))+(22*(1+234))))))+(1+(8+(33*(1+(8+(33*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))+(8+(33*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *city) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Name = string(data[p : p+lName])
		p += lName
	}

	{
		var p000 *city
		if p++; data[p-1] != 0 {
			v100 := city{}
			if err = v100.unmarshalFrom(&p, data); err != nil {
				return
			}
			p000 = &v100
		}
		me.ClosestTo = p000
	}

	{
		lCompanies := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Companies = make([]company, lCompanies)
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = me.Companies[i0].unmarshalFrom(&p, data); err != nil {
				return
			}
		}
	}

	{
		var p000 *[]family
		if p++; data[p-1] != 0 {
			lFamilies := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := make([]family, lFamilies)
			for i0 := 0; i0 < (lFamilies); i0++ {
				v100[i0] = family{}
				if err = v100[i0].unmarshalFrom(&p, data); err != nil {
					return
				}
			}
			p000 = &v100
		}
		me.Families = p000
	}

	{
		var p000 *[]*school
		if p++; data[p-1] != 0 {
			lSchools := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := make([]*school, lSchools)
			for i0 := 0; i0 < (lSchools); i0++ {
				{
					var p010 *school
					if p++; data[p-1] != 0 {
						v110 := school{}
						if err = v110.unmarshalFrom(&p, data); err != nil {
							return
						}
						p010 = &v110
					}
					v100[i0] = p010
				}
			}
			p000 = &v100
		}
		me.Schools = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *city) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *city) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *city) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.Name))+(1+234)+(8+(len(me.Companies)*(8+(33*(1+234)))+(8+(33*(1+234)))+(8+(33*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))+(1+(8+(33*(8+44)+(8+(22*(8+44))+(22*(1+234))))))+(1+(8+(33*(1+(8+(33*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))+(8+(33*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* company:
   3 field(s)

   The serialization view:
   - Suppliers - []*company
   - Clients - []*company
   - Staff - []*person
*/

func (me *company) structVersion() uint64 {
	return 17539614992760979000
}

func (me *company) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lSuppliers := (len(me.Suppliers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lSuppliers))[:])
		for i0 := 0; i0 < (lSuppliers); i0++ {
			if me.Suppliers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Suppliers[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	{
		lClients := (len(me.Clients))
		buf.Write((*[8]byte)(unsafe.Pointer(&lClients))[:])
		for i0 := 0; i0 < (lClients); i0++ {
			if me.Clients[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Clients[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	{
		lStaff := (len(me.Staff))
		buf.Write((*[8]byte)(unsafe.Pointer(&lStaff))[:])
		for i0 := 0; i0 < (lStaff); i0++ {
			if me.Staff[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Staff[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *company) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+(len(me.Suppliers)*(1+234)))+(8+(len(me.Clients)*(1+234)))+(8+(len(me.Staff)*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *company) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lSuppliers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Suppliers = make([]*company, lSuppliers)
		for i0 := 0; i0 < (lSuppliers); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Suppliers[i0] = p010
			}
		}
	}

	{
		lClients := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Clients = make([]*company, lClients)
		for i0 := 0; i0 < (lClients); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Clients[i0] = p010
			}
		}
	}

	{
		lStaff := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Staff = make([]*person, lStaff)
		for i0 := 0; i0 < (lStaff); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Staff[i0] = p010
			}
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *company) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *company) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *company) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+(len(me.Suppliers)*(1+234)))+(8+(len(me.Clients)*(1+234)))+(8+(len(me.Staff)*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* family:
   2 field(s)

   The serialization view:
   - LastName - string
   - Pets - *petPiranha | *petHamster | *petCat | *petDog
*/

func (me *family) structVersion() uint64 {
	return 8599601846628952182
}

func (me *family) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lLastName := (len(me.LastName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastName))[:])
		buf.WriteString(me.LastName)
	}

	{
		lPets := (len(me.Pets))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPets))[:])
		for k0, m0 := range me.Pets {
			lk0 := (len(k0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
			buf.WriteString(k0)
			if m0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv014 := *m0
				{
					switch t := pv014.(type) {
					case *petPiranha:
						buf.WriteByte(1)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case *petHamster:
						buf.WriteByte(2)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case *petCat:
						buf.WriteByte(3)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case *petDog:
						buf.WriteByte(4)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case nil:
						buf.WriteByte(0)
					default:
						panic("family.marshalTo: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
						// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
					}
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *family) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.LastName))+(8+(len(me.Pets)*(8+44))+(len(me.Pets)*(1+234)))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *family) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lLastName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.LastName = string(data[p : p+lLastName])
		p += lLastName
	}

	{
		lPets := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Pets = make(map[string]*petAnimal, lPets)
		for i0 := 0; i0 < (lPets); i0++ {
			var bk0 string
			var bm0 *petAnimal
			lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bk0 = string(data[p : p+lk0])
			p += lk0
			{
				var p014 *petAnimal
				if p++; data[p-1] != 0 {
					var v114 petAnimal
					{
						t := data[p]
						p++
						switch t {
						case 1:
							var u *petPiranha
							{
								var p010 *petPiranha
								if p++; data[p-1] != 0 {
									v110 := petPiranha{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 2:
							var u *petHamster
							{
								var p010 *petHamster
								if p++; data[p-1] != 0 {
									v110 := petHamster{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 3:
							var u *petCat
							{
								var p010 *petCat
								if p++; data[p-1] != 0 {
									v110 := petCat{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 4:
							var u *petDog
							{
								var p010 *petDog
								if p++; data[p-1] != 0 {
									v110 := petDog{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						default:
							v114 = nil
						}
					}
					p014 = &v114
				}
				bm0 = p014
			}
			me.Pets[bk0] = bm0
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *family) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *family) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *family) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.LastName))+(8+(len(me.Pets)*(8+44))+(len(me.Pets)*(1+234)))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* fixedSize:
   13 field(s), always 3384b

   The serialization view:
   - eight1 - float64, 8b, begins fixed-size span of ~3380b (+padding/alignment..) that co-opts the next 12 field(s)
   - eight2 - [1]uint64, 8b
   - eight3 - [2][3]int64, 48b
   - eight4 - [4][5]complex64, 160b
   - four1 - [6][7]float32, 168b
   - four2 - [8][9]int32, 288b
   - four3 - [8][7]uint32, 224b
   - four4 - [6][5]rune, 120b
   - one1 - [4][3]uint8, 12b
   - one2 - [2][1]int8, 2b
   - one3 - [2][3]byte, 6b
   - sixt1 - [4][5]complex128, 320b
   - sixt2 - [6][7]complex384, 2016b
*/

func (me *fixedSize) structVersion() uint64 {
	return 3387551728070519514
}

func (me *fixedSize) marshalTo(buf *bytes.Buffer) (err error) {

	buf.Write((*[3384]byte)(unsafe.Pointer(me))[:])

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *fixedSize) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *fixedSize) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	*me = *((*fixedSize)(unsafe.Pointer(&data[p])))
	p += 3384

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *fixedSize) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *fixedSize) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *fixedSize) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* hobby:
   8 field(s)

   The serialization view:
   - Name - string
   - PopularityScore - float64, 8b, begins fixed-size span of ~46b (+padding/alignment..) that co-opts the next 5 field(s)
   - AvgPerDay.TimeNeededMinMax - [2]time.Duration, 16b
   - AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere - bool, 1b
   - AvgPerDay.CostInCentsMinMax - [2]uint16, 4b
   - GroupSizeMinMax - [2]uint, 16b
   - Outdoorsy - bool, 1b
   - Description - *string
*/

func (me *hobby) structVersion() uint64 {
	return 5837267412986298571
}

func (me *hobby) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lName := (len(me.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(me.Name)
	}

	buf.Write((*[46]byte)(unsafe.Pointer(&me.PopularityScore))[:])

	if me.Description == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Description
		{
			lDescription := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lDescription))[:])
			buf.WriteString(pv000)
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *hobby) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.Name))+8+16+1+4+16+1+(1+(8+44))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *hobby) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Name = string(data[p : p+lName])
		p += lName
	}

	*((*[46]byte)(unsafe.Pointer(&me.PopularityScore))) = *((*[46]byte)(unsafe.Pointer(&data[p])))
	p += 46

	{
		var p000 *string
		if p++; data[p-1] != 0 {
			lDescription := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := string(data[p : p+lDescription])
			p += lDescription
			p000 = &v100
		}
		me.Description = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *hobby) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *hobby) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *hobby) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.Name))+8+16+1+4+16+1+(1+(8+44))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* person:
   6 field(s)

   The serialization view:
   - FirstName - string
   - Family - *family
   - DateOfBirth - time.Time
   - Parents - [2]*person
   - FavPet - *petPiranha | *petHamster | *petCat | *petDog
   - Top5Hobbies - [5]hobby
*/

func (me *person) structVersion() uint64 {
	return 12437898434566093295
}

func (me *person) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lFirstName := (len(me.FirstName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lFirstName))[:])
		buf.WriteString(me.FirstName)
	}

	if me.Family == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Family
		if err = pv000.marshalTo(buf); err != nil {
			return
		}
	}

	{
		d, e := me.DateOfBirth.MarshalBinary()
		if err = e; err != nil {
			return
		}
		lDateOfBirth := (len(d))
		buf.Write((*[8]byte)(unsafe.Pointer(&lDateOfBirth))[:])
		buf.Write(d)
	}

	for i0 := 0; i0 < 2; i0++ {
		if me.Parents[i0] == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv010 := *me.Parents[i0]
			if err = pv010.marshalTo(buf); err != nil {
				return
			}
		}
	}

	{
		switch t := me.FavPet.(type) {
		case *petPiranha:
			buf.WriteByte(1)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case *petHamster:
			buf.WriteByte(2)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case *petCat:
			buf.WriteByte(3)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case *petDog:
			buf.WriteByte(4)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case nil:
			buf.WriteByte(0)
		default:
			panic("person.marshalTo, FavPet field: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
			// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
		}
	}

	for i0 := 0; i0 < 5; i0++ {
		if err = me.Top5Hobbies[i0].marshalTo(buf); err != nil {
			return
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *person) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.FirstName))+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *person) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lFirstName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.FirstName = string(data[p : p+lFirstName])
		p += lFirstName
	}

	{
		var p000 *family
		if p++; data[p-1] != 0 {
			v100 := family{}
			if err = v100.unmarshalFrom(&p, data); err != nil {
				return
			}
			p000 = &v100
		}
		me.Family = p000
	}

	{
		lDateOfBirth := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		if lDateOfBirth > 0 {
			if err = me.DateOfBirth.UnmarshalBinary(data[p : p+lDateOfBirth]); err != nil {
				return
			}
			p += lDateOfBirth
		}
	}

	for i0 := 0; i0 < 2; i0++ {
		{
			var p010 *person
			if p++; data[p-1] != 0 {
				v110 := person{}
				if err = v110.unmarshalFrom(&p, data); err != nil {
					return
				}
				p010 = &v110
			}
			me.Parents[i0] = p010
		}
	}

	{
		t := data[p]
		p++
		switch t {
		case 1:
			var u *petPiranha
			{
				var p000 *petPiranha
				if p++; data[p-1] != 0 {
					v100 := petPiranha{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 2:
			var u *petHamster
			{
				var p000 *petHamster
				if p++; data[p-1] != 0 {
					v100 := petHamster{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 3:
			var u *petCat
			{
				var p000 *petCat
				if p++; data[p-1] != 0 {
					v100 := petCat{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 4:
			var u *petDog
			{
				var p000 *petDog
				if p++; data[p-1] != 0 {
					v100 := petDog{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		default:
			me.FavPet = nil
		}
	}

	for i0 := 0; i0 < 5; i0++ {
		if err = me.Top5Hobbies[i0].unmarshalFrom(&p, data); err != nil {
			return
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *person) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *person) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *person) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+len(me.FirstName))+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* pet:
   6 field(s)

   The serialization view:
   - DailyFoodBill - float32, 4b, begins fixed-size span of ~20b (+padding/alignment..) that co-opts the next 2 field(s)
   - AgeWhenAdopted - int64, 8b
   - LastIllness.Days - int64, 8b
   - LastIllness.Date - *time.Time
   - LastIllness.Notes - []string
   - OrigCostIfKnown - *complex128
*/

func (me *pet) structVersion() uint64 {
	return 13186359848934745181
}

func (me *pet) marshalTo(buf *bytes.Buffer) (err error) {

	buf.Write((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))[:])

	if me.LastIllness.Date == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.LastIllness.Date
		{
			d, e := pv000.MarshalBinary()
			if err = e; err != nil {
				return
			}
			lLastIllnessDate := (len(d))
			buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessDate))[:])
			buf.Write(d)
		}
	}

	{
		lLastIllnessNotes := (len(me.LastIllness.Notes))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessNotes))[:])
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (len(me.LastIllness.Notes[i0]))
			buf.Write((*[8]byte)(unsafe.Pointer(&li0))[:])
			buf.WriteString(me.LastIllness.Notes[i0])
		}
	}

	if me.OrigCostIfKnown == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.OrigCostIfKnown
		buf.Write(((*[16]byte)(unsafe.Pointer(&(pv000))))[:])
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *pet) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.LastIllness.Notes)*(8+44)))+(1+16)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *pet) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	*((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))) = *((*[20]byte)(unsafe.Pointer(&data[p])))
	p += 20

	{
		var p000 *time.Time
		if p++; data[p-1] != 0 {
			v100 := time.Time{}
			{
				lLastIllnessDate := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				if lLastIllnessDate > 0 {
					if err = v100.UnmarshalBinary(data[p : p+lLastIllnessDate]); err != nil {
						return
					}
					p += lLastIllnessDate
				}
			}
			p000 = &v100
		}
		me.LastIllness.Date = p000
	}

	{
		lLastIllnessNotes := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.LastIllness.Notes = make([]string, lLastIllnessNotes)
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			me.LastIllness.Notes[i0] = string(data[p : p+li0])
			p += li0
		}
	}

	{
		var p000 *complex128
		if p++; data[p-1] != 0 {
			v100 := *((*complex128)(unsafe.Pointer(&data[p])))
			p += 16
			p000 = &v100
		}
		me.OrigCostIfKnown = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *pet) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *pet) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *pet) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.LastIllness.Notes)*(8+44)))+(1+16)))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* petCat:
   2 field(s)

   The serialization view:
   - pet - pet
   - RabbitsSlaynPerDayOnAvg - *uint8
*/

func (me *petCat) structVersion() uint64 {
	return 10328327121215776800
}

func (me *petCat) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	if me.RabbitsSlaynPerDayOnAvg == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.RabbitsSlaynPerDayOnAvg
		buf.WriteByte(pv000)
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petCat) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(1+1)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petCat) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	{
		var p000 *uint8
		if p++; data[p-1] != 0 {
			v100 := data[p]
			p++
			p000 = &v100
		}
		me.RabbitsSlaynPerDayOnAvg = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petCat) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petCat) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petCat) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(1+1)))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* petDog:
   2 field(s)

   The serialization view:
   - pet - pet
   - WalkLog - *map[*time.Time][7]time.Duration
*/

func (me *petDog) structVersion() uint64 {
	return 13481847725794463905
}

func (me *petDog) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	if me.WalkLog == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.WalkLog
		{
			lWalkLog := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lWalkLog))[:])
			for k0, m0 := range pv000 {
				if k0 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					pv010 := *k0
					{
						d, e := pv010.MarshalBinary()
						if err = e; err != nil {
							return
						}
						lk0 := (len(d))
						buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
						buf.Write(d)
					}
				}
				buf.Write(((*[56]byte)(unsafe.Pointer(&(m0[0]))))[:])
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petDog) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(1+(8+(22*(1+234))+(22*(7*(8)))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petDog) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	{
		var p000 *map[*time.Time][7]time.Duration
		if p++; data[p-1] != 0 {
			lWalkLog := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := make(map[*time.Time][7]time.Duration, lWalkLog)
			for i0 := 0; i0 < (lWalkLog); i0++ {
				var bk0 *time.Time
				var bm0 [7]time.Duration
				{
					var p010 *time.Time
					if p++; data[p-1] != 0 {
						v110 := time.Time{}
						{
							lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
							p += 8
							if lk0 > 0 {
								if err = v110.UnmarshalBinary(data[p : p+lk0]); err != nil {
									return
								}
								p += lk0
							}
						}
						p010 = &v110
					}
					bk0 = p010
				}
				bm0 = *((*[7]time.Duration)(unsafe.Pointer(&data[p])))
				p += 56
				v100[bk0] = bm0
			}
			p000 = &v100
		}
		me.WalkLog = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petDog) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petDog) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petDog) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(1+(8+(22*(1+234))+(22*(7*(8)))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* petHamster:
   1 field(s)

   The serialization view:
   - pet - pet
*/

func (me *petHamster) structVersion() uint64 {
	return 3668387203931970709
}

func (me *petHamster) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petHamster) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petHamster) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petHamster) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petHamster) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petHamster) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* petPiranha:
   2 field(s)

   The serialization view:
   - pet - pet
   - Weird - map[*[2048]byte][]fixedSize
*/

func (me *petPiranha) structVersion() uint64 {
	return 10060652816787623047
}

func (me *petPiranha) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	{
		lWeird := (len(me.Weird))
		buf.Write((*[8]byte)(unsafe.Pointer(&lWeird))[:])
		for k0, m0 := range me.Weird {
			if k0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *k0
				buf.Write(((*[2048]byte)(unsafe.Pointer(&(pv010[0]))))[:])
			}
			lm0 := (len(m0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lm0))[:])
			if (lm0) > 0 && (lm0) < 634600 {
				buf.Write((*[2147483647]byte)(unsafe.Pointer(&m0[0]))[:3384*(lm0)])
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					buf.Write((*[3384]byte)(unsafe.Pointer(&m0[i1]))[:])
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petPiranha) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(8+(len(me.Weird)*(1+(2048*(1))))+(len(me.Weird)*(8+(33*3384))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petPiranha) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	{
		lWeird := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Weird = make(map[*[2048]byte][]fixedSize, lWeird)
		for i0 := 0; i0 < (lWeird); i0++ {
			var bk0 *[2048]byte
			var bm0 []fixedSize
			{
				var p010 *[2048]byte
				if p++; data[p-1] != 0 {
					v110 := *((*[2048]byte)(unsafe.Pointer(&data[p])))
					p += 2048
					p010 = &v110
				}
				bk0 = p010
			}
			lm0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bm0 = make([]fixedSize, lm0)
			if (lm0) > 0 && (lm0) < 634600 {
				lmul := 3384 * (lm0)
				copy(((*[2147483647]byte)(unsafe.Pointer(&bm0[0])))[0:lmul], data[p:p+(lmul)])
				p += (lmul)
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					bm0[i1] = *((*fixedSize)(unsafe.Pointer(&data[p])))
					p += 3384
				}
			}
			me.Weird[bk0] = bm0
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petPiranha) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petPiranha) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petPiranha) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, 4+8+8+(1+234)+(8+(len(me.pet.LastIllness.Notes)*(8+44)))+(1+16)+(8+(len(me.Weird)*(1+(2048*(1))))+(len(me.Weird)*(8+(33*3384))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* school:
   2 field(s)

   The serialization view:
   - Teachers - []*person
   - Pupils - []*person
*/

func (me *school) structVersion() uint64 {
	return 15855399974602017432
}

func (me *school) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lTeachers := (len(me.Teachers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lTeachers))[:])
		for i0 := 0; i0 < (lTeachers); i0++ {
			if me.Teachers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Teachers[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	{
		lPupils := (len(me.Pupils))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPupils))[:])
		for i0 := 0; i0 < (lPupils); i0++ {
			if me.Pupils[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Pupils[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *school) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+(len(me.Teachers)*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))+(8+(len(me.Pupils)*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *school) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lTeachers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Teachers = make([]*person, lTeachers)
		for i0 := 0; i0 < (lTeachers); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Teachers[i0] = p010
			}
		}
	}

	{
		lPupils := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Pupils = make([]*person, lPupils)
		for i0 := 0; i0 < (lPupils); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Pupils[i0] = p010
			}
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *school) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *school) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *school) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (8+(len(me.Teachers)*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))+(8+(len(me.Pupils)*(1+(8+44)+(1+(8+44)+(8+(22*(8+44))+(22*(1+234))))+234+(2*(1+234))+234+(5*((8+44)+8+16+1+4+16+1+(1+(8+44)))))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}

/* simWorld:
   1 field(s)

   The serialization view:
   - Cities - [123]city
*/

func (me *simWorld) structVersion() uint64 {
	return 8229792174223923377
}

func (me *simWorld) marshalTo(buf *bytes.Buffer) (err error) {

	for i0 := 0; i0 < 123; i0++ {
		if err = me.Cities[i0].marshalTo(buf); err != nil {
			return
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *simWorld) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (123 * ((8 + 44) + (1 + 234) + (8 + (33*(8+(33*(1+234))) + (8 + (33 * (1 + 234))) + (8 + (33 * (1 + (8 + 44) + (1 + (8 + 44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))) + 234 + (2 * (1 + 234)) + 234 + (5 * ((8 + 44) + 8 + 16 + 1 + 4 + 16 + 1 + (1 + (8 + 44))))))))) + (1 + (8 + (33*(8+44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))))) + (1 + (8 + (33 * (1 + (8 + (33 * (1 + (8 + 44) + (1 + (8 + 44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))) + 234 + (2 * (1 + 234)) + 234 + (5 * ((8 + 44) + 8 + 16 + 1 + 4 + 16 + 1 + (1 + (8 + 44))))))) + (8 + (33 * (1 + (8 + 44) + (1 + (8 + 44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))) + 234 + (2 * (1 + 234)) + 234 + (5 * ((8 + 44) + 8 + 16 + 1 + 4 + 16 + 1 + (1 + (8 + 44)))))))))))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *simWorld) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	for i0 := 0; i0 < 123; i0++ {
		if err = me.Cities[i0].unmarshalFrom(&p, data); err != nil {
			return
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *simWorld) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *simWorld) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *simWorld) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, (123 * ((8 + 44) + (1 + 234) + (8 + (33*(8+(33*(1+234))) + (8 + (33 * (1 + 234))) + (8 + (33 * (1 + (8 + 44) + (1 + (8 + 44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))) + 234 + (2 * (1 + 234)) + 234 + (5 * ((8 + 44) + 8 + 16 + 1 + 4 + 16 + 1 + (1 + (8 + 44))))))))) + (1 + (8 + (33*(8+44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))))) + (1 + (8 + (33 * (1 + (8 + (33 * (1 + (8 + 44) + (1 + (8 + 44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))) + 234 + (2 * (1 + 234)) + 234 + (5 * ((8 + 44) + 8 + 16 + 1 + 4 + 16 + 1 + (1 + (8 + 44))))))) + (8 + (33 * (1 + (8 + 44) + (1 + (8 + 44) + (8 + (22 * (8 + 44)) + (22 * (1 + 234)))) + 234 + (2 * (1 + 234)) + 234 + (5 * ((8 + 44) + 8 + 16 + 1 + 4 + 16 + 1 + (1 + (8 + 44)))))))))))))))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}
