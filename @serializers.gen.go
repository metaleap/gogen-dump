package main

// Code generated by github.com/metaleap/gogen-dump - DO NOT EDIT.

// This file consists solely of generated (de)serialization methods for these 13 struct types:
// - city
// - company
// - family
// - fixedSize
// - hobby
// - person
// - pet
// - petCat
// - petDog
// - petHamster
// - petPiranha
// - school
// - simWorld

import (
	"bytes"
	"errors"
	"io"
	"unsafe"

	time "time"
)

/* city:
   5 field(s)

   The serialization view:
   - Name - string
   - ClosestTo - *city
   - Companies - []company
   - Families - *[]family
   - Schools - []*school
*/

func (me *city) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lName := (len(me.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(me.Name)
	}

	if me.ClosestTo == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.ClosestTo
		if err = pv000.marshalTo(buf); err != nil {
			return
		}
	}

	{
		lCompanies := (len(me.Companies))
		buf.Write((*[8]byte)(unsafe.Pointer(&lCompanies))[:])
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = me.Companies[i0].marshalTo(buf); err != nil {
				return
			}
		}
	}

	if me.Families == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Families
		{
			lFamilies := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lFamilies))[:])
			for i0 := 0; i0 < (lFamilies); i0++ {
				if err = pv000[i0].marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	{
		lSchools := (len(me.Schools))
		buf.Write((*[8]byte)(unsafe.Pointer(&lSchools))[:])
		for i0 := 0; i0 < (lSchools); i0++ {
			if me.Schools[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Schools[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *city) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((((8 + len(me.Name)) + 9) + (8 + (len(me.Companies) * 1074))) + 151) + (8 + (len(me.Schools) * 2045)))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *city) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Name = string(data[p : p+lName])
		p += lName
	}

	{
		var p000 *city
		if p++; data[p-1] != 0 {
			v100 := city{}
			if err = v100.unmarshalFrom(&p, data); err != nil {
				return
			}
			p000 = &v100
		}
		me.ClosestTo = p000
	}

	{
		lCompanies := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Companies = make([]company, lCompanies)
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = me.Companies[i0].unmarshalFrom(&p, data); err != nil {
				return
			}
		}
	}

	{
		var p000 *[]family
		if p++; data[p-1] != 0 {
			lFamilies := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := make([]family, lFamilies)
			for i0 := 0; i0 < (lFamilies); i0++ {
				v100[i0] = family{}
				if err = v100[i0].unmarshalFrom(&p, data); err != nil {
					return
				}
			}
			p000 = &v100
		}
		me.Families = p000
	}

	{
		lSchools := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Schools = make([]*school, lSchools)
		for i0 := 0; i0 < (lSchools); i0++ {
			{
				var p010 *school
				if p++; data[p-1] != 0 {
					v110 := school{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Schools[i0] = p010
			}
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *city) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *city) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 6593994633469704441 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *city) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((((8 + len(me.Name)) + 9) + (8 + (len(me.Companies) * 1074))) + 151) + (8 + (len(me.Schools) * 2045)))))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{6593994633469704441, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* company:
   3 field(s)

   The serialization view:
   - Suppliers - []*company
   - Clients - []*company
   - Staff - []*person
*/

func (me *company) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lSuppliers := (len(me.Suppliers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lSuppliers))[:])
		for i0 := 0; i0 < (lSuppliers); i0++ {
			if me.Suppliers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Suppliers[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	{
		lClients := (len(me.Clients))
		buf.Write((*[8]byte)(unsafe.Pointer(&lClients))[:])
		for i0 := 0; i0 < (lClients); i0++ {
			if me.Clients[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Clients[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	{
		lStaff := (len(me.Staff))
		buf.Write((*[8]byte)(unsafe.Pointer(&lStaff))[:])
		for i0 := 0; i0 < (lStaff); i0++ {
			if me.Staff[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Staff[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *company) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((8 + (len(me.Suppliers) * 9)) + (8 + (len(me.Clients) * 9))) + (8 + (len(me.Staff) * 507)))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *company) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lSuppliers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Suppliers = make([]*company, lSuppliers)
		for i0 := 0; i0 < (lSuppliers); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Suppliers[i0] = p010
			}
		}
	}

	{
		lClients := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Clients = make([]*company, lClients)
		for i0 := 0; i0 < (lClients); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Clients[i0] = p010
			}
		}
	}

	{
		lStaff := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Staff = make([]*person, lStaff)
		for i0 := 0; i0 < (lStaff); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Staff[i0] = p010
			}
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *company) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *company) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 1099423678947472881 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *company) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((8 + (len(me.Suppliers) * 9)) + (8 + (len(me.Clients) * 9))) + (8 + (len(me.Staff) * 507)))))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{1099423678947472881, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* family:
   2 field(s)

   The serialization view:
   - LastName - string
   - Pets - map[string]*petAnimal = [ *petCat | *petDog | *petHamster | *petPiranha ]
*/

func (me *family) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lLastName := (len(me.LastName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastName))[:])
		buf.WriteString(me.LastName)
	}

	{
		lPets := (len(me.Pets))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPets))[:])
		for k0, m0 := range me.Pets {
			lk0 := (len(k0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
			buf.WriteString(k0)
			if m0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv014 := *m0
				{
					switch t := pv014.(type) {
					case *petCat:
						buf.WriteByte(1)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case *petDog:
						buf.WriteByte(2)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case *petHamster:
						buf.WriteByte(3)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case *petPiranha:
						buf.WriteByte(4)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							pv010 := *t
							if err = pv010.marshalTo(buf); err != nil {
								return
							}
						}
					case nil:
						buf.WriteByte(0)
					default:
						panic("family.marshalTo: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
						// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
					}
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *family) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + len(me.LastName)) + (8 + ((len(me.Pets) * 15) + (len(me.Pets) * 9))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *family) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lLastName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.LastName = string(data[p : p+lLastName])
		p += lLastName
	}

	{
		lPets := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Pets = make(map[string]*petAnimal, lPets)
		for i0 := 0; i0 < (lPets); i0++ {
			var bk0 string
			var bm0 *petAnimal
			lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bk0 = string(data[p : p+lk0])
			p += lk0
			{
				var p014 *petAnimal
				if p++; data[p-1] != 0 {
					var v114 petAnimal
					{
						t := data[p]
						p++
						switch t {
						case 1:
							var u *petCat
							{
								var p010 *petCat
								if p++; data[p-1] != 0 {
									v110 := petCat{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 2:
							var u *petDog
							{
								var p010 *petDog
								if p++; data[p-1] != 0 {
									v110 := petDog{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 3:
							var u *petHamster
							{
								var p010 *petHamster
								if p++; data[p-1] != 0 {
									v110 := petHamster{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 4:
							var u *petPiranha
							{
								var p010 *petPiranha
								if p++; data[p-1] != 0 {
									v110 := petPiranha{}
									if err = v110.unmarshalFrom(&p, data); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						default:
							v114 = nil
						}
					}
					p014 = &v114
				}
				bm0 = p014
			}
			me.Pets[bk0] = bm0
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *family) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *family) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 4523365645226592426 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *family) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + len(me.LastName)) + (8 + ((len(me.Pets) * 15) + (len(me.Pets) * 9))))))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{4523365645226592426, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* fixedSize:
   13 field(s), always 3384b

   The serialization view:
   - eight1 - float64, 8b, begins fixed-size span of ~3380b (+padding/alignment..) that co-opts the next 12 field(s)
   - eight2 - [1]uint64, 8b
   - eight3 - [2][3]int64, 48b
   - eight4 - [4][5]complex64, 160b
   - four1 - [6][7]float32, 168b
   - four2 - [8][9]int32, 288b
   - four3 - [8][7]uint32, 224b
   - four4 - [6][5]rune, 120b
   - one1 - [4][3]uint8, 12b
   - one2 - [2][1]int8, 2b
   - one3 - [2][3]byte, 6b
   - sixt1 - [4][5]complex128, 320b
   - sixt2 - [6][7]complex384, 2016b
*/

func (me *fixedSize) marshalTo(buf *bytes.Buffer) (err error) {

	buf.Write((*[3384]byte)(unsafe.Pointer(me))[:])

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *fixedSize) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *fixedSize) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	*me = *((*fixedSize)(unsafe.Pointer(&data[p])))
	p += 3384

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *fixedSize) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *fixedSize) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 3387551728070519514 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *fixedSize) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{3387551728070519514, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* hobby:
   8 field(s)

   The serialization view:
   - Name - string
   - PopularityScore - float64, 8b, begins fixed-size span of ~46b (+padding/alignment..) that co-opts the next 5 field(s)
   - AvgPerDay.TimeNeededMinMax - [2]time.Duration, 16b
   - AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere - bool, 1b
   - AvgPerDay.CostInCentsMinMax - [2]uint16, 4b
   - GroupSizeMinMax - [2]uint, 16b
   - Outdoorsy - bool, 1b
   - Description - *string
*/

func (me *hobby) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lName := (len(me.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(me.Name)
	}

	buf.Write((*[46]byte)(unsafe.Pointer(&me.PopularityScore))[:])

	if me.Description == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Description
		{
			lDescription := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lDescription))[:])
			buf.WriteString(pv000)
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *hobby) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((((((((8 + len(me.Name)) + 8) + 16) + 1) + 4) + 16) + 1) + 16)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *hobby) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Name = string(data[p : p+lName])
		p += lName
	}

	*((*[46]byte)(unsafe.Pointer(&me.PopularityScore))) = *((*[46]byte)(unsafe.Pointer(&data[p])))
	p += 46

	{
		var p000 *string
		if p++; data[p-1] != 0 {
			lDescription := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := string(data[p : p+lDescription])
			p += lDescription
			p000 = &v100
		}
		me.Description = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *hobby) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *hobby) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 5837267412986298571 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *hobby) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((((((((8 + len(me.Name)) + 8) + 16) + 1) + 4) + 16) + 1) + 16)))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{5837267412986298571, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* person:
   6 field(s)

   The serialization view:
   - FirstName - string
   - Family - *family
   - DateOfBirth - time.Time
   - Parents - [2]*person
   - FavPet - interface{} = [ *petCat | *petDog | *petHamster | *petPiranha ]
   - Top5Hobbies - [5]hobby
*/

func (me *person) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lFirstName := (len(me.FirstName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lFirstName))[:])
		buf.WriteString(me.FirstName)
	}

	if me.Family == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.Family
		if err = pv000.marshalTo(buf); err != nil {
			return
		}
	}

	{
		d, e := me.DateOfBirth.MarshalBinary()
		if err = e; err != nil {
			return
		}
		lDateOfBirth := (len(d))
		buf.Write((*[8]byte)(unsafe.Pointer(&lDateOfBirth))[:])
		buf.Write(d)
	}

	for i0 := 0; i0 < 2; i0++ {
		if me.Parents[i0] == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv010 := *me.Parents[i0]
			if err = pv010.marshalTo(buf); err != nil {
				return
			}
		}
	}

	{
		switch t := me.FavPet.(type) {
		case *petCat:
			buf.WriteByte(1)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case *petDog:
			buf.WriteByte(2)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case *petHamster:
			buf.WriteByte(3)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case *petPiranha:
			buf.WriteByte(4)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv000 := *t
				if err = pv000.marshalTo(buf); err != nil {
					return
				}
			}
		case nil:
			buf.WriteByte(0)
		default:
			panic("person.marshalTo, FavPet field: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
			// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
		}
	}

	for i0 := 0; i0 < 5; i0++ {
		if err = me.Top5Hobbies[i0].marshalTo(buf); err != nil {
			return
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *person) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((((((8 + len(me.FirstName)) + 72) + 8) + 18) + 8) + 385)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *person) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lFirstName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.FirstName = string(data[p : p+lFirstName])
		p += lFirstName
	}

	{
		var p000 *family
		if p++; data[p-1] != 0 {
			v100 := family{}
			if err = v100.unmarshalFrom(&p, data); err != nil {
				return
			}
			p000 = &v100
		}
		me.Family = p000
	}

	{
		lDateOfBirth := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		if lDateOfBirth > 0 {
			if err = me.DateOfBirth.UnmarshalBinary(data[p : p+lDateOfBirth]); err != nil {
				return
			}
			p += lDateOfBirth
		}
	}

	for i0 := 0; i0 < 2; i0++ {
		{
			var p010 *person
			if p++; data[p-1] != 0 {
				v110 := person{}
				if err = v110.unmarshalFrom(&p, data); err != nil {
					return
				}
				p010 = &v110
			}
			me.Parents[i0] = p010
		}
	}

	{
		t := data[p]
		p++
		switch t {
		case 1:
			var u *petCat
			{
				var p000 *petCat
				if p++; data[p-1] != 0 {
					v100 := petCat{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 2:
			var u *petDog
			{
				var p000 *petDog
				if p++; data[p-1] != 0 {
					v100 := petDog{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 3:
			var u *petHamster
			{
				var p000 *petHamster
				if p++; data[p-1] != 0 {
					v100 := petHamster{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		case 4:
			var u *petPiranha
			{
				var p000 *petPiranha
				if p++; data[p-1] != 0 {
					v100 := petPiranha{}
					if err = v100.unmarshalFrom(&p, data); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			me.FavPet = u
		default:
			me.FavPet = nil
		}
	}

	for i0 := 0; i0 < 5; i0++ {
		if err = me.Top5Hobbies[i0].unmarshalFrom(&p, data); err != nil {
			return
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *person) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *person) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 11925296559860657288 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *person) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((((((8 + len(me.FirstName)) + 72) + 8) + 18) + 8) + 385)))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{11925296559860657288, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* pet:
   6 field(s)

   The serialization view:
   - DailyFoodBill - float32, 4b, begins fixed-size span of ~20b (+padding/alignment..) that co-opts the next 2 field(s)
   - AgeWhenAdopted - int64, 8b
   - LastIllness.Days - int64, 8b
   - LastIllness.Date - *time.Time
   - LastIllness.Notes - []string
   - OrigCostIfKnown - *complex128
*/

func (me *pet) marshalTo(buf *bytes.Buffer) (err error) {

	buf.Write((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))[:])

	if me.LastIllness.Date == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.LastIllness.Date
		{
			d, e := pv000.MarshalBinary()
			if err = e; err != nil {
				return
			}
			lLastIllnessDate := (len(d))
			buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessDate))[:])
			buf.Write(d)
		}
	}

	{
		lLastIllnessNotes := (len(me.LastIllness.Notes))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessNotes))[:])
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (len(me.LastIllness.Notes[i0]))
			buf.Write((*[8]byte)(unsafe.Pointer(&li0))[:])
			buf.WriteString(me.LastIllness.Notes[i0])
		}
	}

	if me.OrigCostIfKnown == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.OrigCostIfKnown
		buf.Write(((*[16]byte)(unsafe.Pointer(&(pv000))))[:])
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *pet) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *pet) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	*((*[20]byte)(unsafe.Pointer(&me.DailyFoodBill))) = *((*[20]byte)(unsafe.Pointer(&data[p])))
	p += 20

	{
		var p000 *time.Time
		if p++; data[p-1] != 0 {
			v100 := time.Time{}
			{
				lLastIllnessDate := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				if lLastIllnessDate > 0 {
					if err = v100.UnmarshalBinary(data[p : p+lLastIllnessDate]); err != nil {
						return
					}
					p += lLastIllnessDate
				}
			}
			p000 = &v100
		}
		me.LastIllness.Date = p000
	}

	{
		lLastIllnessNotes := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.LastIllness.Notes = make([]string, lLastIllnessNotes)
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			me.LastIllness.Notes[i0] = string(data[p : p+li0])
			p += li0
		}
	}

	{
		var p000 *complex128
		if p++; data[p-1] != 0 {
			v100 := *((*complex128)(unsafe.Pointer(&data[p])))
			p += 16
			p000 = &v100
		}
		me.OrigCostIfKnown = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *pet) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *pet) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 13186359848934745181 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *pet) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{13186359848934745181, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* petCat:
   2 field(s)

   The serialization view:
   - pet - pet
   - RabbitsSlaynPerDayOnAvg - *uint8
*/

func (me *petCat) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	if me.RabbitsSlaynPerDayOnAvg == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.RabbitsSlaynPerDayOnAvg
		buf.WriteByte(pv000)
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petCat) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 2)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petCat) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	{
		var p000 *uint8
		if p++; data[p-1] != 0 {
			v100 := data[p]
			p++
			p000 = &v100
		}
		me.RabbitsSlaynPerDayOnAvg = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petCat) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petCat) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 13481110904349996911 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petCat) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 2)))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{13481110904349996911, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* petDog:
   2 field(s)

   The serialization view:
   - pet - pet
   - WalkLog - *map[*time.Time][7]time.Duration
*/

func (me *petDog) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	if me.WalkLog == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *me.WalkLog
		{
			lWalkLog := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lWalkLog))[:])
			for k0, m0 := range pv000 {
				if k0 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					pv010 := *k0
					{
						d, e := pv010.MarshalBinary()
						if err = e; err != nil {
							return
						}
						lk0 := (len(d))
						buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
						buf.Write(d)
					}
				}
				buf.Write(((*[56]byte)(unsafe.Pointer(&(m0[0]))))[:])
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petDog) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 139)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petDog) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	{
		var p000 *map[*time.Time][7]time.Duration
		if p++; data[p-1] != 0 {
			lWalkLog := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := make(map[*time.Time][7]time.Duration, lWalkLog)
			for i0 := 0; i0 < (lWalkLog); i0++ {
				var bk0 *time.Time
				var bm0 [7]time.Duration
				{
					var p010 *time.Time
					if p++; data[p-1] != 0 {
						v110 := time.Time{}
						{
							lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
							p += 8
							if lk0 > 0 {
								if err = v110.UnmarshalBinary(data[p : p+lk0]); err != nil {
									return
								}
								p += lk0
							}
						}
						p010 = &v110
					}
					bk0 = p010
				}
				bm0 = *((*[7]time.Duration)(unsafe.Pointer(&data[p])))
				p += 56
				v100[bk0] = bm0
			}
			p000 = &v100
		}
		me.WalkLog = p000
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petDog) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petDog) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 3596748310628763049 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petDog) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + 139)))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{3596748310628763049, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* petHamster:
   1 field(s)

   The serialization view:
   - pet - pet
*/

func (me *petHamster) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petHamster) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petHamster) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petHamster) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petHamster) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 13333275131017623849 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petHamster) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17)))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{13333275131017623849, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* petPiranha:
   2 field(s)

   The serialization view:
   - pet - pet
   - Weird - map[*[2048]byte][]fixedSize
*/

func (me *petPiranha) marshalTo(buf *bytes.Buffer) (err error) {

	if err = me.pet.marshalTo(buf); err != nil {
		return
	}

	{
		lWeird := (len(me.Weird))
		buf.Write((*[8]byte)(unsafe.Pointer(&lWeird))[:])
		for k0, m0 := range me.Weird {
			if k0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *k0
				buf.Write(((*[2048]byte)(unsafe.Pointer(&(pv010[0]))))[:])
			}
			lm0 := (len(m0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lm0))[:])
			if (lm0) > 0 && (lm0) < 634600 {
				buf.Write((*[2147483647]byte)(unsafe.Pointer(&m0[0]))[:3384*(lm0)])
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					buf.Write((*[3384]byte)(unsafe.Pointer(&m0[i1]))[:])
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *petPiranha) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + (8 + ((len(me.Weird) * 2049) + (len(me.Weird) * 6776))))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *petPiranha) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	if err = me.pet.unmarshalFrom(&p, data); err != nil {
		return
	}

	{
		lWeird := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Weird = make(map[*[2048]byte][]fixedSize, lWeird)
		for i0 := 0; i0 < (lWeird); i0++ {
			var bk0 *[2048]byte
			var bm0 []fixedSize
			{
				var p010 *[2048]byte
				if p++; data[p-1] != 0 {
					v110 := *((*[2048]byte)(unsafe.Pointer(&data[p])))
					p += 2048
					p010 = &v110
				}
				bk0 = p010
			}
			lm0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bm0 = make([]fixedSize, lm0)
			if (lm0) > 0 && (lm0) < 634600 {
				lmul := 3384 * (lm0)
				copy(((*[2147483647]byte)(unsafe.Pointer(&bm0[0])))[0:lmul], data[p:p+(lmul)])
				p += (lmul)
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					bm0[i1] = *((*fixedSize)(unsafe.Pointer(&data[p])))
					p += 3384
				}
			}
			me.Weird[bk0] = bm0
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *petPiranha) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *petPiranha) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 11146996824496730984 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *petPiranha) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(me.pet.LastIllness.Notes) * 15))) + 17) + (8 + ((len(me.Weird) * 2049) + (len(me.Weird) * 6776))))))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{11146996824496730984, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* school:
   2 field(s)

   The serialization view:
   - Teachers - []*person
   - Pupils - []*person
*/

func (me *school) marshalTo(buf *bytes.Buffer) (err error) {

	{
		lTeachers := (len(me.Teachers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lTeachers))[:])
		for i0 := 0; i0 < (lTeachers); i0++ {
			if me.Teachers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Teachers[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	{
		lPupils := (len(me.Pupils))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPupils))[:])
		for i0 := 0; i0 < (lPupils); i0++ {
			if me.Pupils[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *me.Pupils[i0]
				if err = pv010.marshalTo(buf); err != nil {
					return
				}
			}
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *school) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + (len(me.Teachers) * 507)) + (8 + (len(me.Pupils) * 507)))))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *school) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	{
		lTeachers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Teachers = make([]*person, lTeachers)
		for i0 := 0; i0 < (lTeachers); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Teachers[i0] = p010
			}
		}
	}

	{
		lPupils := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		me.Pupils = make([]*person, lPupils)
		for i0 := 0; i0 < (lPupils); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data); err != nil {
						return
					}
					p010 = &v110
				}
				me.Pupils[i0] = p010
			}
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *school) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *school) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 11190834307079325616 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *school) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + (len(me.Teachers) * 507)) + (8 + (len(me.Pupils) * 507)))))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{11190834307079325616, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}

/* simWorld:
   1 field(s)

   The serialization view:
   - Cities - [123]city
*/

func (me *simWorld) marshalTo(buf *bytes.Buffer) (err error) {

	for i0 := 0; i0 < 123; i0++ {
		if err = me.Cities[i0].marshalTo(buf); err != nil {
			return
		}
	}

	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data`.
func (me *simWorld) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 790767))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

func (me *simWorld) unmarshalFrom(pos *int, data []byte) (err error) {
	p := *pos

	for i0 := 0; i0 < 123; i0++ {
		if err = me.Cities[i0].unmarshalFrom(&p, data); err != nil {
			return
		}
	}

	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` into `me`.
func (me *simWorld) UnmarshalBinary(data []byte) (err error) {
	var pos0 int
	err = me.unmarshalFrom(&pos0, data)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
func (me *simWorld) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		if data := buf.Bytes(); len(data) < 16 {
			err = errors.New("ELENGTH: not enough data for header")
		} else if header := *((*[2]uint64)(unsafe.Pointer(&data[0]))); header[0] != 13412975302553189149 {
			err = errors.New("ESCHEMA: incompatible schema-header")
		} else if dump := data[16:]; uint64(len(dump)) != header[1] {
			err = errors.New("ELENGTH: actual length does not match length-header")
		} else {
			var pos0 int
			err = me.unmarshalFrom(&pos0, data)
		}
	}
	return
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
func (me *simWorld) WriteTo(w io.Writer) (n int64, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, 790767))
	if err = me.marshalTo(buf); err == nil {
		header := [2]uint64{13412975302553189149, uint64(buf.Len())}
		w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:])
		n, err = buf.WriteTo(w)
		n += 16
	}
	return
}
