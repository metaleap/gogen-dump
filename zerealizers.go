package main

// Code generated by github.com/metaleap/gogen-dump - DO NUT EDIT.

// This file consists solely of generated (de)serialization methods for the following 13 struct type(s).
// - city (signature: 3970122804759536109)
// - company (signature: 5055412192963965693)
// - family (signature: 8682289633696798851)
// - fixedSize (signature: 3387551728070519514)
// - hobby (signature: 5837267412986298571)
// - person (signature: 8784308003182413552)
// - pet (signature: 13186359848934745181)
// - petCat (signature: 13481110904349996911)
// - petDog (signature: 3596748310628763049)
// - petHamster (signature: 13333275131017623849)
// - petPiranha (signature: 1259503521920636675)
// - school (signature: 11738600557355911093)
// - simWorld (signature: 17948359994441385067)

import (
	"bytes"
	"errors"
	"io"
	"unsafe"

	"time"
)

/* city:
   5 field(s)

   The serialization view:
   - Name - string
   - ClosestTo - *****city
   - Companies - []company
   - Families - **[]family
   - Schools - **[]**school
*/

func (this *city) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// Name
	{
		lName := (len(this.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(this.Name)
	}
	// ClosestTo
	if this.ClosestTo == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *this.ClosestTo
		if pv000 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv100 := *pv000
			if pv100 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv200 := *pv100
				if pv200 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					pv300 := *pv200
					if pv300 == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						if err = pv300.marshalTo(buf /*, addrs*/); err != nil {
							return
						}
					}
				}
			}
		}
	}
	// Companies
	{
		lCompanies := (len(this.Companies))
		buf.Write((*[8]byte)(unsafe.Pointer(&lCompanies))[:])
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = this.Companies[i0].marshalTo(buf /*, addrs*/); err != nil {
				return
			}
		}
	}
	// Families
	if this.Families == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *this.Families
		if pv000 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv100 := *pv000
			{
				lFamilies := (len(pv100))
				buf.Write((*[8]byte)(unsafe.Pointer(&lFamilies))[:])
				for i0 := 0; i0 < (lFamilies); i0++ {
					if err = pv100[i0].marshalTo(buf /*, addrs*/); err != nil {
						return
					}
				}
			}
		}
	}
	// Schools
	if this.Schools == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *this.Schools
		if pv000 == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			pv100 := *pv000
			{
				lSchools := (len(pv100))
				buf.Write((*[8]byte)(unsafe.Pointer(&lSchools))[:])
				for i0 := 0; i0 < (lSchools); i0++ {
					if pv100[i0] == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						pv010 := *pv100[i0]
						if pv010 == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = pv010.marshalTo(buf /*, addrs*/); err != nil {
								return
							}
						}
					}
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *city) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((((8 + len(this.Name)) + 13) + (8 + (len(this.Companies) * 1074))) + 152) + 4102)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *city) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// Name
	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Name = string(data[p : p+lName])
		p += lName
	}
	// ClosestTo
	{
		var p000 *****city
		if p++; data[p-1] != 0 {
			var p100 ****city
			if p++; data[p-1] != 0 {
				var p200 ***city
				if p++; data[p-1] != 0 {
					var p300 **city
					if p++; data[p-1] != 0 {
						var p400 *city
						if p++; data[p-1] != 0 {
							v500 := city{}
							if err = v500.unmarshalFrom(&p, data /*, addrs*/); err != nil {
								return
							}
							p400 = &v500
						}
						p300 = &p400
					}
					p200 = &p300
				}
				p100 = &p200
			}
			p000 = &p100
		}
		this.ClosestTo = p000
	}
	// Companies
	{
		lCompanies := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Companies = make([]company, lCompanies)
		for i0 := 0; i0 < (lCompanies); i0++ {
			if err = this.Companies[i0].unmarshalFrom(&p, data /*, addrs*/); err != nil {
				return
			}
		}
	}
	// Families
	{
		var p000 **[]family
		if p++; data[p-1] != 0 {
			var p100 *[]family
			if p++; data[p-1] != 0 {
				lFamilies := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				v200 := make([]family, lFamilies)
				for i0 := 0; i0 < (lFamilies); i0++ {
					v200[i0] = family{}
					if err = v200[i0].unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
				}
				p100 = &v200
			}
			p000 = &p100
		}
		this.Families = p000
	}
	// Schools
	{
		var p000 **[]**school
		if p++; data[p-1] != 0 {
			var p100 *[]**school
			if p++; data[p-1] != 0 {
				lSchools := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				v200 := make([]**school, lSchools)
				for i0 := 0; i0 < (lSchools); i0++ {
					{
						var p010 **school
						if p++; data[p-1] != 0 {
							var p110 *school
							if p++; data[p-1] != 0 {
								v210 := school{}
								if err = v210.unmarshalFrom(&p, data /*, addrs*/); err != nil {
									return
								}
								p110 = &v210
							}
							p010 = &p110
						}
						v200[i0] = p010
					}
				}
				p100 = &v200
			}
			p000 = &p100
		}
		this.Schools = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *city) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *city) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 3970122804759536109 {
			err = errors.New("city: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *city) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((((8 + len(this.Name)) + 13) + (8 + (len(this.Companies) * 1074))) + 152) + 4102)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{3970122804759536109, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* company:
   3 field(s)

   The serialization view:
   - Suppliers - []*company
   - Clients - []*company
   - Staff - []*person
*/

func (this *company) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// Suppliers
	{
		lSuppliers := (len(this.Suppliers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lSuppliers))[:])
		for i0 := 0; i0 < (lSuppliers); i0++ {
			if this.Suppliers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = this.Suppliers[i0].marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		}
	}
	// Clients
	{
		lClients := (len(this.Clients))
		buf.Write((*[8]byte)(unsafe.Pointer(&lClients))[:])
		for i0 := 0; i0 < (lClients); i0++ {
			if this.Clients[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = this.Clients[i0].marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		}
	}
	// Staff
	{
		lStaff := (len(this.Staff))
		buf.Write((*[8]byte)(unsafe.Pointer(&lStaff))[:])
		for i0 := 0; i0 < (lStaff); i0++ {
			if this.Staff[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = this.Staff[i0].marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *company) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((8 + (len(this.Suppliers) * 9)) + (8 + (len(this.Clients) * 9))) + (8 + (len(this.Staff) * 507)))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *company) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// Suppliers
	{
		lSuppliers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Suppliers = make([]*company, lSuppliers)
		for i0 := 0; i0 < (lSuppliers); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p010 = &v110
				}
				this.Suppliers[i0] = p010
			}
		}
	}
	// Clients
	{
		lClients := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Clients = make([]*company, lClients)
		for i0 := 0; i0 < (lClients); i0++ {
			{
				var p010 *company
				if p++; data[p-1] != 0 {
					v110 := company{}
					if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p010 = &v110
				}
				this.Clients[i0] = p010
			}
		}
	}
	// Staff
	{
		lStaff := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Staff = make([]*person, lStaff)
		for i0 := 0; i0 < (lStaff); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p010 = &v110
				}
				this.Staff[i0] = p010
			}
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *company) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *company) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 5055412192963965693 {
			err = errors.New("company: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *company) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((8 + (len(this.Suppliers) * 9)) + (8 + (len(this.Clients) * 9))) + (8 + (len(this.Staff) * 507)))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{5055412192963965693, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* family:
   2 field(s)

   The serialization view:
   - LastName - string
   - Pets - map[string]*petAnimal = [ *petCat | *petDog | *petHamster | *petPiranha ]
*/

func (this *family) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// LastName
	{
		lLastName := (len(this.LastName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastName))[:])
		buf.WriteString(this.LastName)
	}
	// Pets
	{
		lPets := (len(this.Pets))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPets))[:])
		for k0, m0 := range this.Pets {
			lk0 := (len(k0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
			buf.WriteString(k0)
			if m0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				{
					switch t := (*m0).(type) {
					case *petCat:
						buf.WriteByte(1)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf /*, addrs*/); err != nil {
								return
							}
						}
					case *petDog:
						buf.WriteByte(2)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf /*, addrs*/); err != nil {
								return
							}
						}
					case *petHamster:
						buf.WriteByte(3)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf /*, addrs*/); err != nil {
								return
							}
						}
					case *petPiranha:
						buf.WriteByte(4)
						if t == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							if err = t.marshalTo(buf /*, addrs*/); err != nil {
								return
							}
						}
					case nil:
						buf.WriteByte(0)
					default:
						panic("family.marshalTo: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
						// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
					}
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *family) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + len(this.LastName)) + (8 + ((len(this.Pets) * 15) + (len(this.Pets) * 9))))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *family) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// LastName
	{
		lLastName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.LastName = string(data[p : p+lLastName])
		p += lLastName
	}
	// Pets
	{
		lPets := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Pets = make(map[string]*petAnimal, lPets)
		for i0 := 0; i0 < (lPets); i0++ {
			var bk0 string
			var bm0 *petAnimal
			lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bk0 = string(data[p : p+lk0])
			p += lk0
			{
				var p014 *petAnimal
				if p++; data[p-1] != 0 {
					var v114 petAnimal
					{
						t := data[p]
						p++
						switch t {
						case 1:
							var u *petCat
							{
								var p010 *petCat
								if p++; data[p-1] != 0 {
									v110 := petCat{}
									if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 2:
							var u *petDog
							{
								var p010 *petDog
								if p++; data[p-1] != 0 {
									v110 := petDog{}
									if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 3:
							var u *petHamster
							{
								var p010 *petHamster
								if p++; data[p-1] != 0 {
									v110 := petHamster{}
									if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						case 4:
							var u *petPiranha
							{
								var p010 *petPiranha
								if p++; data[p-1] != 0 {
									v110 := petPiranha{}
									if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
										return
									}
									p010 = &v110
								}
								u = p010
							}
							v114 = u
						default:
							v114 = nil
						}
					}
					p014 = &v114
				}
				bm0 = p014
			}
			this.Pets[bk0] = bm0
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *family) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *family) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 8682289633696798851 {
			err = errors.New("family: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *family) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + len(this.LastName)) + (8 + ((len(this.Pets) * 15) + (len(this.Pets) * 9))))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{8682289633696798851, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* fixedSize:
   13 field(s), always 3384b

   The serialization view:
   - eight1 - float64, 8b, begins fixed-size span of ~3380b (+padding/alignment..) over the next 12 field(s)
   - eight2 - [1]uint64, 8b
   - eight3 - [2][3]int64, 48b
   - eight4 - [4][5]complex64, 160b
   - four1 - [6][7]float32, 168b
   - four2 - [8][9]int32, 288b
   - four3 - [8][7]uint32, 224b
   - four4 - [6][5]rune, 120b
   - one1 - [4][3]uint8, 12b
   - one2 - [2][1]int8, 2b
   - one3 - [2][3]byte, 6b
   - sixt1 - [4][5]complex128, 320b
   - sixt2 - [6][7]complex384, 2016b
*/

func (this *fixedSize) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	buf.Write((*[3384]byte)(unsafe.Pointer(this))[:])
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *fixedSize) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *fixedSize) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	*this = *((*fixedSize)(unsafe.Pointer(&data[*pos])))
	*pos += 3384
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *fixedSize) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *fixedSize) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 3387551728070519514 {
			err = errors.New("fixedSize: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *fixedSize) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 3384))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{3387551728070519514, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* hobby:
   8 field(s)

   The serialization view:
   - Name - string
   - PopularityScore - float64, 8b, begins fixed-size span of ~46b (+padding/alignment..) over the next 5 field(s)
   - AvgPerDay.TimeNeededMinMax - [2]time.Duration, 16b
   - AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere - bool, 1b
   - AvgPerDay.CostInCentsMinMax - [2]uint16, 4b
   - GroupSizeMinMax - [2]uint, 16b
   - Outdoorsy - bool, 1b
   - Description - *string
*/

func (this *hobby) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// Name
	{
		lName := (len(this.Name))
		buf.Write((*[8]byte)(unsafe.Pointer(&lName))[:])
		buf.WriteString(this.Name)
	}
	// PopularityScore, AvgPerDay.TimeNeededMinMax, AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere, AvgPerDay.CostInCentsMinMax, GroupSizeMinMax, Outdoorsy
	buf.Write((*[46]byte)(unsafe.Pointer(&this.PopularityScore))[:])
	// Description
	if this.Description == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *this.Description
		{
			lDescription := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lDescription))[:])
			buf.WriteString(pv000)
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *hobby) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((((8 + len(this.Name)) + 8) + 16) + 1) + 4) + 16) + 1) + 16)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *hobby) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// Name
	{
		lName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Name = string(data[p : p+lName])
		p += lName
	}
	// PopularityScore, AvgPerDay.TimeNeededMinMax, AvgPerDay.JustNeedToCheckPaddingAndAlignmentsHere, AvgPerDay.CostInCentsMinMax, GroupSizeMinMax, Outdoorsy
	*((*[46]byte)(unsafe.Pointer(&this.PopularityScore))) = *((*[46]byte)(unsafe.Pointer(&data[p])))
	p += 46
	// Description
	{
		var p000 *string
		if p++; data[p-1] != 0 {
			lDescription := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := string(data[p : p+lDescription])
			p += lDescription
			p000 = &v100
		}
		this.Description = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *hobby) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *hobby) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 5837267412986298571 {
			err = errors.New("hobby: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *hobby) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((((8 + len(this.Name)) + 8) + 16) + 1) + 4) + 16) + 1) + 16)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{5837267412986298571, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* person:
   6 field(s)

   The serialization view:
   - FirstName - string
   - Family - *family
   - DateOfBirth - time.Time
   - Parents - [2]*person
   - FavPet - interface{} = [ *petCat | *petDog | *petHamster | *petPiranha ]
   - Top5Hobbies - [5]hobby
*/

func (this *person) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// FirstName
	{
		lFirstName := (len(this.FirstName))
		buf.Write((*[8]byte)(unsafe.Pointer(&lFirstName))[:])
		buf.WriteString(this.FirstName)
	}
	// Family
	if this.Family == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		if err = this.Family.marshalTo(buf /*, addrs*/); err != nil {
			return
		}
	}
	// DateOfBirth
	{
		d, e := this.DateOfBirth.MarshalBinary()
		if err = e; err != nil {
			return
		}
		lDateOfBirth := (len(d))
		buf.Write((*[8]byte)(unsafe.Pointer(&lDateOfBirth))[:])
		buf.Write(d)
	}
	// Parents
	for i0 := 0; i0 < 2; i0++ {
		if this.Parents[i0] == nil {
			buf.WriteByte(0)
		} else {
			buf.WriteByte(1)
			if err = this.Parents[i0].marshalTo(buf /*, addrs*/); err != nil {
				return
			}
		}
	}
	// FavPet
	{
		switch t := this.FavPet.(type) {
		case *petCat:
			buf.WriteByte(1)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		case *petDog:
			buf.WriteByte(2)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		case *petHamster:
			buf.WriteByte(3)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		case *petPiranha:
			buf.WriteByte(4)
			if t == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = t.marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		case nil:
			buf.WriteByte(0)
		default:
			panic("person.marshalTo, FavPet field: while attempting to serialize a non-nil petAnimal, encountered a concrete type not mentioned in your corresponding tagged-union field-tag")
			// panic(fmt.Sprintf("%T", t)) // don't want fmt in by default, but it's here to uncomment when the temporary need arises
		}
	}
	// Top5Hobbies
	for i0 := 0; i0 < 5; i0++ {
		if err = this.Top5Hobbies[i0].marshalTo(buf /*, addrs*/); err != nil {
			return
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *person) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((8 + len(this.FirstName)) + 72) + 8) + 18) + 8) + 385)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *person) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// FirstName
	{
		lFirstName := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.FirstName = string(data[p : p+lFirstName])
		p += lFirstName
	}
	// Family
	{
		var p000 *family
		if p++; data[p-1] != 0 {
			v100 := family{}
			if err = v100.unmarshalFrom(&p, data /*, addrs*/); err != nil {
				return
			}
			p000 = &v100
		}
		this.Family = p000
	}
	// DateOfBirth
	{
		lDateOfBirth := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		if lDateOfBirth > 0 {
			if err = this.DateOfBirth.UnmarshalBinary(data[p : p+lDateOfBirth]); err != nil {
				return
			}
			p += lDateOfBirth
		}
	}
	// Parents
	for i0 := 0; i0 < 2; i0++ {
		{
			var p010 *person
			if p++; data[p-1] != 0 {
				v110 := person{}
				if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
					return
				}
				p010 = &v110
			}
			this.Parents[i0] = p010
		}
	}
	// FavPet
	{
		t := data[p]
		p++
		switch t {
		case 1:
			var u *petCat
			{
				var p000 *petCat
				if p++; data[p-1] != 0 {
					v100 := petCat{}
					if err = v100.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			this.FavPet = u
		case 2:
			var u *petDog
			{
				var p000 *petDog
				if p++; data[p-1] != 0 {
					v100 := petDog{}
					if err = v100.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			this.FavPet = u
		case 3:
			var u *petHamster
			{
				var p000 *petHamster
				if p++; data[p-1] != 0 {
					v100 := petHamster{}
					if err = v100.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			this.FavPet = u
		case 4:
			var u *petPiranha
			{
				var p000 *petPiranha
				if p++; data[p-1] != 0 {
					v100 := petPiranha{}
					if err = v100.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p000 = &v100
				}
				u = p000
			}
			this.FavPet = u
		default:
			this.FavPet = nil
		}
	}
	// Top5Hobbies
	for i0 := 0; i0 < 5; i0++ {
		if err = this.Top5Hobbies[i0].unmarshalFrom(&p, data /*, addrs*/); err != nil {
			return
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *person) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *person) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 8784308003182413552 {
			err = errors.New("person: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *person) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((((((8 + len(this.FirstName)) + 72) + 8) + 18) + 8) + 385)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{8784308003182413552, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* pet:
   6 field(s)

   The serialization view:
   - DailyFoodBill - float32, 4b, begins fixed-size span of ~20b (+padding/alignment..) over the next 2 field(s)
   - AgeWhenAdopted - int64, 8b
   - LastIllness.Days - int64, 8b
   - LastIllness.Date - *time.Time
   - LastIllness.Notes - []string
   - OrigCostIfKnown - *complex128
*/

func (this *pet) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// DailyFoodBill, AgeWhenAdopted, LastIllness.Days
	buf.Write((*[20]byte)(unsafe.Pointer(&this.DailyFoodBill))[:])
	// LastIllness.Date
	if this.LastIllness.Date == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		{
			d, e := this.LastIllness.Date.MarshalBinary()
			if err = e; err != nil {
				return
			}
			lLastIllnessDate := (len(d))
			buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessDate))[:])
			buf.Write(d)
		}
	}
	// LastIllness.Notes
	{
		lLastIllnessNotes := (len(this.LastIllness.Notes))
		buf.Write((*[8]byte)(unsafe.Pointer(&lLastIllnessNotes))[:])
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (len(this.LastIllness.Notes[i0]))
			buf.Write((*[8]byte)(unsafe.Pointer(&li0))[:])
			buf.WriteString(this.LastIllness.Notes[i0])
		}
	}
	// OrigCostIfKnown
	if this.OrigCostIfKnown == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		buf.Write(((*[16]byte)(unsafe.Pointer(this.OrigCostIfKnown)))[:])
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *pet) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(this.LastIllness.Notes) * 15))) + 17)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *pet) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// DailyFoodBill, AgeWhenAdopted, LastIllness.Days
	*((*[20]byte)(unsafe.Pointer(&this.DailyFoodBill))) = *((*[20]byte)(unsafe.Pointer(&data[p])))
	p += 20
	// LastIllness.Date
	{
		var p000 *time.Time
		if p++; data[p-1] != 0 {
			v100 := time.Time{}
			{
				lLastIllnessDate := (*((*int)(unsafe.Pointer(&data[p]))))
				p += 8
				if lLastIllnessDate > 0 {
					if err = v100.UnmarshalBinary(data[p : p+lLastIllnessDate]); err != nil {
						return
					}
					p += lLastIllnessDate
				}
			}
			p000 = &v100
		}
		this.LastIllness.Date = p000
	}
	// LastIllness.Notes
	{
		lLastIllnessNotes := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.LastIllness.Notes = make([]string, lLastIllnessNotes)
		for i0 := 0; i0 < (lLastIllnessNotes); i0++ {
			li0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			this.LastIllness.Notes[i0] = string(data[p : p+li0])
			p += li0
		}
	}
	// OrigCostIfKnown
	{
		var p000 *complex128
		if p++; data[p-1] != 0 {
			v100 := *((*complex128)(unsafe.Pointer(&data[p])))
			p += 16
			p000 = &v100
		}
		this.OrigCostIfKnown = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *pet) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *pet) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 13186359848934745181 {
			err = errors.New("pet: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *pet) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(this.LastIllness.Notes) * 15))) + 17)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{13186359848934745181, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petCat:
   2 field(s)

   The serialization view:
   - pet - pet
   - RabbitsSlaynPerDayOnAvg - *uint8
*/

func (this *petCat) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// pet
	if err = this.pet.marshalTo(buf /*, addrs*/); err != nil {
		return
	}
	// RabbitsSlaynPerDayOnAvg
	if this.RabbitsSlaynPerDayOnAvg == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		buf.WriteByte((*this.RabbitsSlaynPerDayOnAvg))
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *petCat) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17) + 2)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *petCat) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// pet
	if err = this.pet.unmarshalFrom(&p, data /*, addrs*/); err != nil {
		return
	}
	// RabbitsSlaynPerDayOnAvg
	{
		var p000 *uint8
		if p++; data[p-1] != 0 {
			v100 := data[p]
			p++
			p000 = &v100
		}
		this.RabbitsSlaynPerDayOnAvg = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *petCat) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *petCat) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 13481110904349996911 {
			err = errors.New("petCat: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *petCat) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17) + 2)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{13481110904349996911, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petDog:
   2 field(s)

   The serialization view:
   - pet - pet
   - WalkLog - *map[*time.Time][7]time.Duration
*/

func (this *petDog) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// pet
	if err = this.pet.marshalTo(buf /*, addrs*/); err != nil {
		return
	}
	// WalkLog
	if this.WalkLog == nil {
		buf.WriteByte(0)
	} else {
		buf.WriteByte(1)
		pv000 := *this.WalkLog
		{
			lWalkLog := (len(pv000))
			buf.Write((*[8]byte)(unsafe.Pointer(&lWalkLog))[:])
			for k0, m0 := range pv000 {
				if k0 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					{
						d, e := k0.MarshalBinary()
						if err = e; err != nil {
							return
						}
						lk0 := (len(d))
						buf.Write((*[8]byte)(unsafe.Pointer(&lk0))[:])
						buf.Write(d)
					}
				}
				buf.Write(((*[56]byte)(unsafe.Pointer(&(m0[0]))))[:])
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *petDog) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17) + 139)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *petDog) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// pet
	if err = this.pet.unmarshalFrom(&p, data /*, addrs*/); err != nil {
		return
	}
	// WalkLog
	{
		var p000 *map[*time.Time][7]time.Duration
		if p++; data[p-1] != 0 {
			lWalkLog := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			v100 := make(map[*time.Time][7]time.Duration, lWalkLog)
			for i0 := 0; i0 < (lWalkLog); i0++ {
				var bk0 *time.Time
				var bm0 [7]time.Duration
				{
					var p010 *time.Time
					if p++; data[p-1] != 0 {
						v110 := time.Time{}
						{
							lk0 := (*((*int)(unsafe.Pointer(&data[p]))))
							p += 8
							if lk0 > 0 {
								if err = v110.UnmarshalBinary(data[p : p+lk0]); err != nil {
									return
								}
								p += lk0
							}
						}
						p010 = &v110
					}
					bk0 = p010
				}
				bm0 = *((*[7]time.Duration)(unsafe.Pointer(&data[p])))
				p += 56
				v100[bk0] = bm0
			}
			p000 = &v100
		}
		this.WalkLog = p000
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *petDog) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *petDog) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 3596748310628763049 {
			err = errors.New("petDog: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *petDog) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17) + 139)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{3596748310628763049, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petHamster:
   1 field(s)

   The serialization view:
   - pet - pet
*/

func (this *petHamster) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// pet
	if err = this.pet.marshalTo(buf /*, addrs*/); err != nil {
		return
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *petHamster) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *petHamster) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// pet
	if err = this.pet.unmarshalFrom(&p, data /*, addrs*/); err != nil {
		return
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *petHamster) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *petHamster) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 13333275131017623849 {
			err = errors.New("petHamster: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *petHamster) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17)))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{13333275131017623849, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* petPiranha:
   2 field(s)

   The serialization view:
   - pet - pet
   - Weird - map[****[1234]byte][]fixedSize
*/

func (this *petPiranha) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// pet
	if err = this.pet.marshalTo(buf /*, addrs*/); err != nil {
		return
	}
	// Weird
	{
		lWeird := (len(this.Weird))
		buf.Write((*[8]byte)(unsafe.Pointer(&lWeird))[:])
		for k0, m0 := range this.Weird {
			if k0 == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				pv010 := *k0
				if pv010 == nil {
					buf.WriteByte(0)
				} else {
					buf.WriteByte(1)
					pv110 := *pv010
					if pv110 == nil {
						buf.WriteByte(0)
					} else {
						buf.WriteByte(1)
						pv210 := *pv110
						if pv210 == nil {
							buf.WriteByte(0)
						} else {
							buf.WriteByte(1)
							buf.Write(pv210[:])
						}
					}
				}
			}
			lm0 := (len(m0))
			buf.Write((*[8]byte)(unsafe.Pointer(&lm0))[:])
			if (lm0) > 0 && (lm0) < 332712738429 {
				buf.Write((*[1125899906842623]byte)(unsafe.Pointer(&m0[0]))[:3384*(lm0)])
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					buf.Write((*[3384]byte)(unsafe.Pointer(&m0[i1]))[:])
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *petPiranha) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17) + (8 + ((len(this.Weird) * 1238) + (len(this.Weird) * 6776))))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *petPiranha) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// pet
	if err = this.pet.unmarshalFrom(&p, data /*, addrs*/); err != nil {
		return
	}
	// Weird
	{
		lWeird := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Weird = make(map[****[1234]byte][]fixedSize, lWeird)
		for i0 := 0; i0 < (lWeird); i0++ {
			var bk0 ****[1234]byte
			var bm0 []fixedSize
			{
				var p010 ****[1234]byte
				if p++; data[p-1] != 0 {
					var p110 ***[1234]byte
					if p++; data[p-1] != 0 {
						var p210 **[1234]byte
						if p++; data[p-1] != 0 {
							var p310 *[1234]byte
							if p++; data[p-1] != 0 {
								v410 := *((*[1234]byte)(unsafe.Pointer(&data[p])))
								p += 1234
								p310 = &v410
							}
							p210 = &p310
						}
						p110 = &p210
					}
					p010 = &p110
				}
				bk0 = p010
			}
			lm0 := (*((*int)(unsafe.Pointer(&data[p]))))
			p += 8
			bm0 = make([]fixedSize, lm0)
			if (lm0) > 0 && (lm0) < 332712738429 {
				lmul := 3384 * (lm0)
				copy(((*[1125899906842623]byte)(unsafe.Pointer(&bm0[0])))[0:lmul], data[p:p+(lmul)])
				p += (lmul)
			} else {
				for i1 := 0; i1 < (lm0); i1++ {
					bm0[i1] = *((*fixedSize)(unsafe.Pointer(&data[p])))
					p += 3384
				}
			}
			this.Weird[bk0] = bm0
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *petPiranha) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *petPiranha) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 1259503521920636675 {
			err = errors.New("petPiranha: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *petPiranha) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, (((29 + (8 + (len(this.pet.LastIllness.Notes) * 15))) + 17) + (8 + ((len(this.Weird) * 1238) + (len(this.Weird) * 6776))))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{1259503521920636675, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* school:
   2 field(s)

   The serialization view:
   - Teachers - []*person
   - Pupils - []*person
*/

func (this *school) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// Teachers
	{
		lTeachers := (len(this.Teachers))
		buf.Write((*[8]byte)(unsafe.Pointer(&lTeachers))[:])
		for i0 := 0; i0 < (lTeachers); i0++ {
			if this.Teachers[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = this.Teachers[i0].marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		}
	}
	// Pupils
	{
		lPupils := (len(this.Pupils))
		buf.Write((*[8]byte)(unsafe.Pointer(&lPupils))[:])
		for i0 := 0; i0 < (lPupils); i0++ {
			if this.Pupils[i0] == nil {
				buf.WriteByte(0)
			} else {
				buf.WriteByte(1)
				if err = this.Pupils[i0].marshalTo(buf /*, addrs*/); err != nil {
					return
				}
			}
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *school) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + (len(this.Teachers) * 507)) + (8 + (len(this.Pupils) * 507)))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *school) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// Teachers
	{
		lTeachers := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Teachers = make([]*person, lTeachers)
		for i0 := 0; i0 < (lTeachers); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p010 = &v110
				}
				this.Teachers[i0] = p010
			}
		}
	}
	// Pupils
	{
		lPupils := (*((*int)(unsafe.Pointer(&data[p]))))
		p += 8
		this.Pupils = make([]*person, lPupils)
		for i0 := 0; i0 < (lPupils); i0++ {
			{
				var p010 *person
				if p++; data[p-1] != 0 {
					v110 := person{}
					if err = v110.unmarshalFrom(&p, data /*, addrs*/); err != nil {
						return
					}
					p010 = &v110
				}
				this.Pupils[i0] = p010
			}
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *school) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *school) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 11738600557355911093 {
			err = errors.New("school: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *school) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, ((8 + (len(this.Teachers) * 507)) + (8 + (len(this.Pupils) * 507)))))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{11738600557355911093, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}

/* simWorld:
   1 field(s)

   The serialization view:
   - Cities - [123]city
*/

func (this *simWorld) marshalTo(buf *bytes.Buffer /*, addrs map[uintptr]uint64*/) (err error) {
	// Cities
	for i0 := 0; i0 < 123; i0++ {
		if err = this.Cities[i0].marshalTo(buf /*, addrs*/); err != nil {
			return
		}
	}
	return
}

// MarshalBinary implements `encoding.BinaryMarshaler` by serializing `me` into `data` (that can be consumed by `UnmarshalBinary`).
func (this *simWorld) MarshalBinary() (data []byte, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 791874))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		data = buf.Bytes()
	}
	return
}

func (this *simWorld) unmarshalFrom(pos *int, data []byte /*, addrs map[uint64]uintptr*/) (err error) {
	p := *pos
	// Cities
	for i0 := 0; i0 < 123; i0++ {
		if err = this.Cities[i0].unmarshalFrom(&p, data /*, addrs*/); err != nil {
			return
		}
	}
	*pos = p
	return
}

// UnmarshalBinary implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `me`.
func (this *simWorld) UnmarshalBinary(data []byte) (err error) {
	// var addrs = map[uint64]uintptr{}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data /*, addrs*/)
	return
}

// ReadFrom implements `io.ReaderFrom` by deserializing from `r` into `me`.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from `WriteTo`, any remainder remains unread.
func (this *simWorld) ReadFrom(r io.Reader) (int64, error) {
	// var addrs = map[uint64]uintptr{}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != 17948359994441385067 {
			err = errors.New("simWorld: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data /*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo implements `io.WriterTo` by serializing `me` to `w`.
// `WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively.
func (this *simWorld) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs = map[uintptr]uint64{}
	buf := bytes.NewBuffer(make([]byte, 0, 791874))
	if err = this.marshalTo(buf /*, addrs*/); err == nil {
		header := [2]uint64{17948359994441385067, uint64(buf.Len())}
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = buf.WriteTo(w)
			n += 16
		}
	}
	return
}
