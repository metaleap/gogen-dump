package main

import (
	"bytes"
	"go/format"
	"text/template"
)

const tmplSrc = `package {{.PName}}
// Code generated by {{.ProgHint}} â€” DO NOT EDIT.

// This file consists solely of generated (de)serialization methods for these struct types:
{{range .Structs}}// - {{.TName}}
{{end}}
import (
	"bytes"
	"io"
	"unsafe"
	{{range $pkgname, $pkg := .Imps}}{{if $pkg.Used}}
		{{ $pkgname }} "{{$pkg.ImportPath}}"{{end}}{{end}}
)

{{range .Structs}}
func (me *{{.TName}}) marshalTo(buf *bytes.Buffer) (err error) {
	{{if .TmplW}}
	{{.TmplW}}
	{{else}}
	{{if .HasWData}}var data bytes.Buffer{{end}}
	{{if .HasB0Ptr}}var b0 byte ; var b0s = (*((*[1]byte)(unsafe.Pointer(&b0))))[:] {{end}}
	{{if .HasB1Ptr}}var b1 byte = 1 ; var b1s = (*((*[1]byte)(unsafe.Pointer(&b1))))[:] {{end}}
	{{range .Fields}}
	{{.TmplW}}
	{{end}}
	{{end}}
	return
}

// MarshalBinary implements ` + "`" + `encoding.BinaryMarshaler` + "`" + ` by serializing ` + "`" + `me` + "`" + ` into ` + "`" + `data` + "`" + `.
func (me *{{.TName}}) MarshalBinary() (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0, {{.InitialBufSize}}))
	if err = me.marshalTo(buf); err == nil {
		data = buf.Bytes()
	}
	return
}

// ReadFrom implements ` + "`" + `io.ReaderFrom` + "`" + ` by deserializing from ` + "`" + `r` + "`" + ` into ` + "`" + `me` + "`" + `.
func (me *{{.TName}}) ReadFrom(r io.Reader) (n int64, err error) {
	var buf bytes.Buffer
	if n, err = buf.ReadFrom(r); err == nil {
		err = me.UnmarshalBinary(buf.Bytes())
	}
	return
}

func (me *{{.TName}}) unmarshalFrom(data []byte) (p int, err error) {
	{{if .TmplR}}
	{{.TmplR}}
	{{else}}
	{{range .Fields}}
	{{.TmplR}}
	{{end}}
	{{end}}
	return
}

// UnmarshalBinary implements ` + "`" + `encoding.BinaryUnmarshaler` + "`" + ` by deserializing from ` + "`" + `data` + "`" + ` into ` + "`" + `me` + "`" + `.
func (me *{{.TName}}) UnmarshalBinary(data []byte) (err error) {
	_, err = me.unmarshalFrom(data)
	return
}

// WriteTo implements ` + "`" + `io.WriterTo` + "`" + ` by serializing ` + "`" + `me` + "`" + ` to ` + "`" + `w` + "`" + `.
func (me *{{.TName}}) WriteTo(w io.Writer) (int64, error) {
	buf := bytes.NewBuffer(make([]byte, 0, {{.InitialBufSize}}))
	if err := me.marshalTo(buf); err != nil {
		return 0, err
	}
	return buf.WriteTo(w)
}
{{end}}
`

type tmplDotFile struct {
	ProgHint string
	PName    string
	Structs  []*tmplDotStruct
	Imps     map[string]*tmplDotPkgImp

	allStructTypeDefsCollected bool
}

func (me *tmplDotFile) Len() int               { return len(me.Structs) }
func (me *tmplDotFile) Less(i int, j int) bool { return me.Structs[i].TName < me.Structs[j].TName }
func (me *tmplDotFile) Swap(i int, j int)      { me.Structs[i], me.Structs[j] = me.Structs[j], me.Structs[i] }

type tmplDotPkgImp struct {
	ImportPath string
	Used       bool
}

type tmplDotStruct struct {
	TName          string
	Fields         []*tmplDotField
	HasB0Ptr       bool
	HasB1Ptr       bool
	HasWData       bool
	TmplR          string // only if fixedSize() > 0
	TmplW          string // only if fixedSize() > 0
	InitialBufSize string

	fixedsize int
}

func (me *tmplDotStruct) fixedSize() int {
	if me.fixedsize == 0 && tdot.allStructTypeDefsCollected {
		for _, fld := range me.Fields {
			if fs := fld.fixedSize(); fs < 0 {
				me.fixedsize = -1
				break
			} else if fs == 0 {
				panic("should never occur: " + me.TName + "." + fld.FName)
			} else {
				me.fixedsize += fs
			}
		}
		if me.fixedsize == 0 {
			me.fixedsize = -1
		}
	}
	return me.fixedsize
}

func (me *tmplDotStruct) sizeHeur(exprPref string) string {
	if fs := me.fixedSize(); fs > 0 {
		return s(fs)
	}
	var s string
	for _, tdf := range me.Fields {
		s += "+" + tdf.sizeHeur(exprPref)
	}
	return s[1:]
}

type tmplDotField struct {
	FName string
	TmplW string
	TmplR string

	typeIdent         string
	taggedUnion       []string
	skip              bool
	nextOneWasSkipped bool
	isLast            bool

	fixedsize           int
	fixedsizeExt        int
	fixedsizeExtNumSkip int
	sizeheur            string
}

func (me *tmplDotField) finalTypeIdent() (typeident string) {
	typeident = me.typeIdent
	for tsyn := tSynonyms[typeident]; tsyn != ""; tsyn = tSynonyms[typeident] {
		typeident = tsyn
	}
	return
}

func (me *tmplDotField) fixedSize() int {
	if me.fixedsize == 0 && tdot.allStructTypeDefsCollected {
		me.fixedsize = fixedSizeForTypeSpec(me.typeIdent)
	}
	return me.fixedsize
}

func (me *tmplDotField) sizeHeur(exprPref string) string {
	if fs := me.fixedSize(); fs > 0 {
		return s(fs)
	}
	if exprPref != "" {
		exprPref += me.FName
	}
	return typeSizeHeur(me.finalTypeIdent(), exprPref)
}

func genViaTmpl() (src []byte, err error) {
	tmpl := template.New("gen-tmpl.go")
	if _, err = tmpl.Parse(tmplSrc); err == nil {
		var buf bytes.Buffer
		if err = tmpl.Execute(&buf, &tdot); err == nil {
			src = buf.Bytes()
			if srcfmt, errfmt := format.Source(src); errfmt == nil {
				src = srcfmt
			}
		}
	}
	return
}
