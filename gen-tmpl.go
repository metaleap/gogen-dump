package main

import (
	"bytes"
	"go/format"
	"sort"
	"strconv"
	"text/template"
)

const tmplSrc = `package {{.PName}}
// Code generated by {{.ProgHint}} - DO NOT EDIT.
{{ $bBytes := .BBuf.Bytes }}
{{ $bWriteTo:= .BBuf.WriteTo }}
{{ $bLen := .BBuf.Len }}
{{ $bCtor := .BBuf.Ctor }}
{{ $bType := .BBuf.Type }}
{{ $addrs := .SharedAddrs }}

// This file consists {{if .BBuf.Stdlib}}solely{{else}}largely{{end}} of generated (de)serialization methods for the following {{len .Structs}} struct type(s).
{{range .Structs}}// - {{.TName}} (signature: {{.StructuralHash}})
{{end}}
import (
	{{if .BBuf.Stdlib}}"bytes"{{end}}
	"errors"
	"io"
	"unsafe"
	{{range $pkgname, $pkg := .Imps}}{{if $pkg.Used}}
		{{ $pkgname }} "{{$pkg.ImportPath}}"{{end}}{{end}}
)

{{range .Structs}}

/* {{.TName}}:
   {{.Comment}}

   The serialization view:
{{range .Fields}}   - {{.FName}} - {{.Comment}}
{{end}}*/

func (this *{{.TName}}) marshalTo(buf {{$bType}}/*, addrs map[uintptr]uint64*/) (err error) {
	{{if .TmplW}}{{.TmplW}}
	{{else}}{{range .Fields}}{{if .TmplW}} // {{.FName}}{{.FExtNames}}
	{{.TmplW}}
	{{end}}{{end}}{{end}}return
}

// MarshalBinary` + " implements `encoding.BinaryMarshaler` by serializing `this` into `data` (that can be consumed by `UnmarshalBinary`)" + `.
func (this *{{.TName}}) MarshalBinary() (data []byte, err error) {
	// var addrs {{if $addrs}}= map[uintptr]uint64{}{{else}}map[uintptr]uint64{{end}}
	buf := {{$bCtor}}(make([]byte, 0, {{.InitialBufSize}}))
	if err = this.marshalTo(buf/*, addrs*/); err == nil {
		data = {{$bBytes}}
	}
	return
}

func (this *{{.TName}}) unmarshalFrom(pos *int, data []byte/*, addrs map[uint64]uintptr*/) (err error) {
	{{if .TmplR}}{{.TmplR}}{{else}}p := *pos
	{{range .Fields}}{{if .TmplR}} // {{.FName}}{{.FExtNames}}
	{{.TmplR}}
	{{end}}{{end}}*pos = p{{end}}
	return
}

// UnmarshalBinary` + " implements `encoding.BinaryUnmarshaler` by deserializing from `data` (that was originally produced by `MarshalBinary`) into `this`" + `.
func (this *{{.TName}}) UnmarshalBinary(data []byte) (err error) {
	// var addrs {{if $addrs}}= map[uint64]uintptr{}{{else}}map[uint64]uintptr{{end}}
	var pos0 int
	err = this.unmarshalFrom(&pos0, data/*, addrs*/)
	return
}

// ReadFrom` + " implements `io.ReaderFrom` by deserializing from `r` into `this`" + `.
// It reads only as many bytes as indicated necessary in the initial 16-byte header prefix from ` + "`WriteTo`" + `, any remainder remains unread.
func (this *{{.TName}}) ReadFrom(r io.Reader) (int64, error) {
	// var addrs {{if $addrs}}= map[uint64]uintptr{}{{else}}map[uint64]uintptr{{end}}
	var header [2]uint64
	n, err := io.ReadAtLeast(r, ((*[16]byte)(unsafe.Pointer(&header[0])))[:], 16)
	if err == nil {
		if header[0] != {{.StructuralHash}} {
			err = errors.New("{{.TName}}: incompatible signature header")
		} else {
			data := make([]byte, header[1])
			if n, err = io.ReadAtLeast(r, data, len(data)); err == nil {
				var pos0 int
				err = this.unmarshalFrom(&pos0, data/*, addrs*/)
			}
			n += 16
		}
	}
	return int64(n), err
}

// WriteTo` + " implements `io.WriterTo` by serializing `this` to `w`" + `.
// ` + "`WriteTo` and `ReadFrom` rely on a 16-byte header prefix to the subsequent raw serialization data handled by `MarshalBinary`/`UnmarshalBinary` respectively." + `
func (this *{{.TName}}) WriteTo(w io.Writer) (n int64, err error) {
	// var addrs {{if $addrs}}= map[uintptr]uint64{}{{else}}map[uintptr]uint64{{end}}
	buf := {{$bCtor}}(make([]byte, 0, {{.InitialBufSize}}))
	if err = this.marshalTo(buf/*, addrs*/); err == nil {
		header := [2]uint64 { {{.StructuralHash}}, uint64({{$bLen}}) }
		var l int
		if l, err = w.Write(((*[16]byte)(unsafe.Pointer(&header[0])))[:]); err != nil {
			n = int64(l)
		} else {
			n, err = {{$bWriteTo}}(w)
			n += 16
		}
	}
	return
}
{{end}}
{{if not .BBuf.Stdlib}}
type writeBuf struct{ b []byte }

func writeBuffer(b []byte) *writeBuf {
	return &writeBuf{b: b}
}

func (this *writeBuf) copyTo(to *writeBuf) {
	to.write(this.b)
}

func (this *writeBuf) writeByte(b byte) {
	l, c := len(this.b), cap(this.b)
	if l == c {
		old := this.b
		this.b = make([]byte, l+1, l+l+128) // the constant extra padding: if we're tiny (~0), it helps much; if we're large (MBs), it hurts none
		copy(this.b[:l], old)
	} else {
		this.b = this.b[:l+1]
	}
	this.b[l] = b
}

func (this *writeBuf) write(b []byte) {
	l, c, n := len(this.b), cap(this.b), len(b)
	if ln := l + n; ln > c {
		old := this.b
		this.b = make([]byte, ln, ln+ln+128)
		copy(this.b[:l], old)
	} else {
		this.b = this.b[:ln]
	}
	copy(this.b[l:], b)
}

func (this *writeBuf) writeString(b string) {
	l, c, n := len(this.b), cap(this.b), len(b)
	if ln := l + n; ln > c {
		old := this.b
		this.b = make([]byte, ln, ln+ln+128)
		copy(this.b[:l], old)
	} else {
		this.b = this.b[:ln]
	}
	copy(this.b[l:], b)
}

func (this *writeBuf) writeTo(w io.Writer) (int64, error) {
	n, err := w.Write(this.b)
	return int64(n), err
}
{{end}}
`

type tmplDotFile struct {
	ProgHint    string
	PName       string
	Structs     []*tmplDotStruct
	Imps        map[string]*tmplDotPkgImp
	SharedAddrs bool
	BBuf        struct {
		Stdlib  bool
		Bytes   string
		Ctor    string
		Len     string
		Type    string
		WriteB  string
		WriteS  string
		WriteN  string
		WriteTo string
	}

	allStructTypeDefsCollected bool
}

func (this *tmplDotFile) Len() int               { return len(this.Structs) }
func (this *tmplDotFile) Less(i int, j int) bool { return this.Structs[i].TName < this.Structs[j].TName }
func (this *tmplDotFile) Swap(i int, j int) {
	this.Structs[i], this.Structs[j] = this.Structs[j], this.Structs[i]
}

func (this *tmplDotFile) byName(name string) *tmplDotStruct {
	for _, tds := range this.Structs {
		if tds.TName == name {
			return tds
		}
	}
	return nil
}

type tmplDotPkgImp struct {
	ImportPath string
	Used       bool
}

type tmplDotStruct struct {
	TName          string
	Fields         []*tmplDotField
	TmplR          string // only if fixedSize() > 0 && !optNoFixedSizeCode
	TmplW          string // only if fixedSize() > 0 && !optNoFixedSizeCode
	InitialBufSize string
	StructuralHash uint64
	Comment        string

	hashInputSelf writeBuf
	hashInputRefs writeBuf

	fixedsize   int
	sizeheuring bool
}

func (this *tmplDotStruct) fixedSize() int {
	if this.fixedsize == 0 && tdot.allStructTypeDefsCollected {
		this.fixedsize = -1 // set early in case of recursive type structures
		isfixedsize := true
		for _, fld := range this.Fields {
			if fs := fld.fixedSize(); fs < 0 {
				isfixedsize = false
				break
			} else if fs == 0 {
				panic("should never occur, your recent changes must have introduced a bug: " + this.TName + "." + fld.FName)
			}
		}
		if isfixedsize { // so far we really just verified fixed-size-ness but to get the correct size, need to account for alignments/paddings instead of naively summing field sizes
			if this.fixedsize = int(typeSizes.Sizeof(typeObjs[this.TName])); this.fixedsize == 0 {
				this.fixedsize = -1
			}
		}
	}
	return this.fixedsize
}

func (this *tmplDotStruct) sizeHeur(exprPref string) *sizeHeuristics {
	if this.sizeheuring {
		return &sizeHeuristics{Lit: optHeuristicSizeUnknowns}
	}
	this.sizeheuring = true
	if fs := this.fixedSize(); fs > 0 {
		return &sizeHeuristics{Lit: fs}
	}
	var last *sizeHeuristics
	for _, tdf := range this.Fields {
		this := tdf.sizeHeur(exprPref)
		if last == nil {
			last = this
		} else {
			last = &sizeHeuristics{Op1: last, OpAdd: true, Op2: this}
		}
	}
	this.sizeheuring = false
	return last
}

type tmplDotField struct {
	FName     string
	TmplW     string
	TmplR     string
	Comment   string
	FExtNames string

	typeIdent         string
	taggedUnion       sort.StringSlice
	skip              bool
	nextOneWasSkipped bool
	isLast            bool

	fixedsize           int
	fixedsizeExt        int
	fixedsizeExtNumSkip int
}

func (this *tmplDotField) finalTypeIdent() (typeident string) {
	typeident = this.typeIdent
	for tsyn := typeSyns[typeident]; tsyn != ""; tsyn = typeSyns[typeident] {
		typeident = tsyn
	}
	return
}

func (this *tmplDotField) fixedSize() int {
	if this.fixedsize == 0 && tdot.allStructTypeDefsCollected {
		this.fixedsize = fixedSizeForTypeSpec(this.typeIdent)
	}
	return this.fixedsize
}

func (this *tmplDotField) sizeHeur(exprPref string) *sizeHeuristics {
	if fs := this.fixedSize(); fs > 0 {
		return &sizeHeuristics{Lit: fs}
	} else {
		if exprPref != "" {
			exprPref += this.FName
		}
		return typeSizeHeur(this.finalTypeIdent(), exprPref)
	}
}

func genViaTmpl() (src []byte, err error) {
	tmpl := template.New("gen-tmpl.go")
	if _, err = tmpl.Parse(tmplSrc); err == nil {
		var buf bytes.Buffer
		if err = tmpl.Execute(&buf, &tdot); err == nil {
			src = buf.Bytes()
			if srcfmt, errfmt := format.Source(src); errfmt == nil {
				src = srcfmt
			} else {
				println("be warned! the generated code could not be formatted, so it won't compile either:\n\t" + errfmt.Error())
			}
		}
	}
	return
}

type sizeHeuristics struct {
	Expr  string
	Lit   int
	OpMul bool
	OpAdd bool
	Op1   *sizeHeuristics
	Op2   *sizeHeuristics
}

func (this *sizeHeuristics) isLit() bool {
	return (!this.OpAdd) && (!this.OpMul) && this.Expr == ""
}

func (this *sizeHeuristics) reduce() *sizeHeuristics {
	if this.Op1 != nil && this.Op2 != nil {
		this.Op1, this.Op2 = this.Op1.reduce(), this.Op2.reduce()
		l1, l2 := this.Op1.Lit, this.Op2.Lit
		o1, o2 := this.Op1.isLit(), this.Op2.isLit()
		switch {
		case this.OpMul:

			if l1 == 1 {
				return this.Op2
			} else if l2 == 1 {
				return this.Op1
			} else if (o1 && l1 == 0) || (o2 && l2 == 0) {
				return &sizeHeuristics{}
			} else if o1 && o2 {
				return &sizeHeuristics{Lit: l1 * l2}
			}
		case this.OpAdd:
			if o1 && l1 == 0 {
				return this.Op2
			} else if o2 && l2 == 0 {
				return this.Op1
			} else if o1 && o2 {
				return &sizeHeuristics{Lit: l1 + l2}
			}
		}
	}
	return this
}

func (this *sizeHeuristics) String() string {
	switch {
	case this.isLit():
		return strconv.Itoa(this.Lit)
	case this.Expr != "":
		return this.Expr
	case this.OpMul:
		return "(" + this.Op1.String() + " * " + this.Op2.String() + ")"
	case this.OpAdd:
		return "(" + this.Op1.String() + " + " + this.Op2.String() + ")"
	}
	panic("forgot a case in switch?!")
}
